# Динамика (часть 2)

> Это динамика. _(Один из советов с кф как решать задачи на командных одимпиадах)_

## ДП по поддеревьям

Главной особенностью динамического программирования по поддеревьям является необходимость учитывать ответы в поддеревьях, так как они могут влиять на ответы в других поддеревьях.

### Задача о паросочетании максимального веса в дереве

Пусть задано взвешенное дерево, с весами, обозначенными как $w_{i,j}$, где $i$ и $j$ — вершины дерева, соединённые ребром.. Необходимо составить такое паросочетание, чтобы суммарный вес всех рёбер, входящих в него, был максимальным.

Для решения данной задачи существует несколько алгоритмов. Например, [алгоритм Куна](match.html), который имеет верхнюю оценку порядка $\O \left ( n^3 \right )$. Но так как нам дано дерево, то можно использовать динамическое программирование, время работы алгоритма с которым улучшается до $\O \left ( n \right )$.

Обозначим $a[i]$ как паросочетание максимального веса в поддереве с корнем в $i$-той вершине, при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, входящей в поддерево $i$-ой вершины; аналогично $b[i]$ --- как паросочетание максимального веса в поддерева с корнем в $i$-той вершине, но только при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, не входящей в поддерево $i$-ой вершины; а $c[i]=\max \left ( a[i],b[i] \right )$, таким образом, ответ на задачу будет находиться в $c[root]$, где $root$ --- корень дерева. Идея динамического программирования здесь состоит в том, что для того, чтобы найти паросочетание максимального веса с корнем в вершине $i$, нам необходимо найти максимальное паросочетание для всех поддеревьев $i$-ой вершины.

Обозначим $Ch(x)$ --- как множество сыновей вершины $x$ и будем находить значения $a[x]$ и $b[x]$ следующим образом:

Если вершина $x$ --- лист, то $a[x]=b[x]=0$,

в противном же случае

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}  +\sum_{\substack{z \neq y\\z \in Ch(x)}} \limits \max \left ( a[z],b[z] \right )\right )$,
* $b[x]=\sum_{z \in Ch(x)} \limits \max \left ( a[z], b[z] \right )$

С учётом того, что $c[i]=\max \left ( a[i],b[i] \right )$, эти формулы можно переписать как

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}-c[y] \right )+b[x]$
* $b[x]=\sum_{z \in Ch(x)} \limits c[z]$.


Теперь оценим количество операций, необходимых нам для нахождения $c[root]$. Так как $c[i]=\max \left ( a[i],b[i] \right )$, то для вычисления $c[root]$ необходимо вычислить $a[root]$, $b[root]$. Для вычисления и того, и другого необходимо время порядка $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=O \left ( n \right )$, где $ n $ — число вершин в дереве.

```
// в основной процедуре вызываем dfs от корня(root), после этого ответ будет хранится в c[root]
function dfs(x: int, a: int[], b: int[], c: int[], w: int[][], Ch: int[]): 
    for (i : Ch[x])
        dfs(i, a, b, c, w, Ch)
        // по формуле выше, но без b[x] (прибавим его один раз в конце)
        a[x] = max(a[x], b[i] + w[x][i] - с[i])
        b[x] += с[i]
    // так как в a[x] пока что хранится только на сколько мы можем
    // увеличить ответ если будем использовать вершину x
    a[x] += b[x]
    c[x] = max(a[x], b[x])
```

### Задача о сумме длин всех путей в дереве

Найти сумму длин всех путей в дереве.

Решим эту задачу за $ O(n) $. Пусть задано подвешенное дерево. Рассмотрим количество путей для вершины $ v $. Во-первых, это пути не проходящие через эту вершину, то есть все пути между её сыновьями. Во-вторых, пути, которые оканчиваются вершиной $ v $. И в третьих, это пути проходящие через вершину $ v $, они начинаются из поддерева одного из сыновей этой вершины и заканчиваются в другом поддереве одного из сыновей вершины $ v $.

Теперь подсчитаем пути для каждого варианта. Обозначим $ S[v]\ - $ размер поддерева $ v $, $ F[v]\ - $ сумма длин всех путей вершины $ v $, $ G[v]\ - $ количество путей оканчивающихся вершиной $ v $, $ H[v]\ - $ количество путей проходящих через вершину $ v $. Если вершина $ u $ лист, то $ S[u] $ = 1, а $ G[u] $ = 0.

1. Пути не проходящие через эту вершину. Это просто сумма суммы длин для всех поддеревьев детей или $ \sum_{x \in Ch(v)} \limits F[x]$.

2. Пути оканчивающиеся в вершине $ v $. Рассмотрим ребро, соединяющее вершину $ v $ и одного ее сына, пусть это будет вершина $ g $. Переберем все пути, которые начинаются с этого ребра и идут вниз. Это будет сумма путей оканчивающихся в $ g + S[g] $, так как суммарная длина поддерева $ g $ уже сосчитана и каждый такой путь мы продлили ребром, соединяющим вершины $ v $ и $ g $. Всего таких путей: $ G[v] = \sum_{x \in Ch(v)} \limits {\Bigl(G[x] + S[x]\Bigl)}$.

3. Пути проходящие через вершину $ v $. Рассмотрим двух сыновей этой вершины: $ x $ и $ y $. Нам надо подсчитать все пути, которые поднимаются из поддерева $ x $ в $ v $ и затем опускаются в поддерево $ y $ и наоборот. То есть по каждому пути, оканчивающимся в вершине $ x $ мы пройдем столько раз сколько элементов в поддереве $ y $, следовательно таких путей будет $ G[x]S[y] $. Аналогично, если будем подниматься из поддерева $ y $. Также надо учитывать сколько раз мы проходим по ребрам, соединяющим вершины $ x $ $ v $ и $ y $ $ x $. Итого для двух вершин $ x $ и $ y $: $ G[x]S[y] + G[y]S[x] + 2S[x]S[y]  $, следовательно ( $ x,y \in Ch(v)$) $ H[v] = \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y] + G[y]S[x] + 2S[x]S[y]\Bigl)} $. Но такой подсчет испортит асимптотику до $ O(n^2) $. Заметим, что $ \sum_{x,y} \limits {\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} $. Но еще надо учесть, что $ x \ne y $, следовательно $ \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} $. Аналогично для $ S[x]S[y] $. Итак: $ H[v] = 2\biggl(\sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} \biggl) + 2\biggl(\sum_{x} \limits {S[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(S[x]S[x]\Bigl)} \biggl) $.

Ответ задачи: $ F[v] = \sum_{x \in Ch(v)} \limits F[x] + G[v] + H[v] $. Асимптотика каждого слагаемого равна $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=\O \left ( n \right )$, где $ n $ — число вершин в дереве, следовательно и время работы самого алгоритма $ \O \left (n \right ) $.

### Амортизированные оценки для ДП на дереве

Пусть какой-либо алгоритм на дереве работает за время $\O \left ( \left |Ch \left ( x \right) \right |^k \right )$ для вершины x, тогда время обработки им всего дерева не превышает $\O \left ( n^k \right )$:

**Доказательство.** $\forall x \in \left \\{ 1 \dots n \right \\}: \left | Ch(x) \right | \leqslant n$, поэтому $\sum_{x=1}^n \limits \left | Ch \left ( x \right ) \right |^k \leqslant \sum_{x=1}^n \limits | Ch \left ( x \right ) | \cdot n^{k-1}=n \cdot n^{k-1}=n^k$.

## ДП по подмноженствам

## ДП по профилю
