# Динамика (часть 2)

> Это динамика. _(Один из советов с кф как решать задачи на командных одимпиадах)_

## ДП по поддеревьям

Главной особенностью динамического программирования по поддеревьям является необходимость учитывать ответы в поддеревьях, так как они могут влиять на ответы в других поддеревьях.

### Задача о паросочетании максимального веса в дереве

Пусть задано взвешенное дерево, с весами, обозначенными как $w_{i,j}$, где $i$ и $j$ — вершины дерева, соединённые ребром.. Необходимо составить такое паросочетание, чтобы суммарный вес всех рёбер, входящих в него, был максимальным.

Для решения данной задачи существует несколько алгоритмов. Например, [алгоритм Куна](match.html), который имеет верхнюю оценку порядка $\O \left ( n^3 \right )$. Но так как нам дано дерево, то можно использовать динамическое программирование, время работы алгоритма с которым улучшается до $\O \left ( n \right )$.

Обозначим $a[i]$ как паросочетание максимального веса в поддереве с корнем в $i$-той вершине, при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, входящей в поддерево $i$-ой вершины; аналогично $b[i]$ --- как паросочетание максимального веса в поддерева с корнем в $i$-той вершине, но только при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, не входящей в поддерево $i$-ой вершины; а $c[i]=\max \left ( a[i],b[i] \right )$, таким образом, ответ на задачу будет находиться в $c[root]$, где $root$ --- корень дерева. Идея динамического программирования здесь состоит в том, что для того, чтобы найти паросочетание максимального веса с корнем в вершине $i$, нам необходимо найти максимальное паросочетание для всех поддеревьев $i$-ой вершины.

Обозначим $Ch(x)$ --- как множество сыновей вершины $x$ и будем находить значения $a[x]$ и $b[x]$ следующим образом:

Если вершина $x$ --- лист, то $a[x]=b[x]=0$,

в противном же случае

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}  +\sum_{\substack{z \neq y\\z \in Ch(x)}} \limits \max \left ( a[z],b[z] \right )\right )$,
* $b[x]=\sum_{z \in Ch(x)} \limits \max \left ( a[z], b[z] \right )$

С учётом того, что $c[i]=\max \left ( a[i],b[i] \right )$, эти формулы можно переписать как

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}-c[y] \right )+b[x]$
* $b[x]=\sum_{z \in Ch(x)} \limits c[z]$.


Теперь оценим количество операций, необходимых нам для нахождения $c[root]$. Так как $c[i]=\max \left ( a[i],b[i] \right )$, то для вычисления $c[root]$ необходимо вычислить $a[root]$, $b[root]$. Для вычисления и того, и другого необходимо время порядка $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=O \left ( n \right )$, где $ n $ — число вершин в дереве.

```
// в основной процедуре вызываем dfs от корня(root), после этого ответ будет хранится в c[root]
function dfs(x: int, a: int[], b: int[], c: int[], w: int[][], Ch: int[]): 
    for (i : Ch[x])
        dfs(i, a, b, c, w, Ch)
        // по формуле выше, но без b[x] (прибавим его один раз в конце)
        a[x] = max(a[x], b[i] + w[x][i] - с[i])
        b[x] += с[i]
    // так как в a[x] пока что хранится только на сколько мы можем
    // увеличить ответ если будем использовать вершину x
    a[x] += b[x]
    c[x] = max(a[x], b[x])
```

### Задача о сумме длин всех путей в дереве

Найти сумму длин всех путей в дереве.

Решим эту задачу за $ O(n) $. Пусть задано подвешенное дерево. Рассмотрим количество путей для вершины $ v $. Во-первых, это пути не проходящие через эту вершину, то есть все пути между её сыновьями. Во-вторых, пути, которые оканчиваются вершиной $ v $. И в третьих, это пути проходящие через вершину $ v $, они начинаются из поддерева одного из сыновей этой вершины и заканчиваются в другом поддереве одного из сыновей вершины $ v $.

Теперь подсчитаем пути для каждого варианта. Обозначим $ S[v]\ - $ размер поддерева $ v $, $ F[v]\ - $ сумма длин всех путей вершины $ v $, $ G[v]\ - $ количество путей оканчивающихся вершиной $ v $, $ H[v]\ - $ количество путей проходящих через вершину $ v $. Если вершина $ u $ лист, то $ S[u] $ = 1, а $ G[u] $ = 0.

1. Пути не проходящие через эту вершину. Это просто сумма суммы длин для всех поддеревьев детей или $ \sum_{x \in Ch(v)} \limits F[x]$.

2. Пути оканчивающиеся в вершине $ v $. Рассмотрим ребро, соединяющее вершину $ v $ и одного ее сына, пусть это будет вершина $ g $. Переберем все пути, которые начинаются с этого ребра и идут вниз. Это будет сумма путей оканчивающихся в $ g + S[g] $, так как суммарная длина поддерева $ g $ уже сосчитана и каждый такой путь мы продлили ребром, соединяющим вершины $ v $ и $ g $. Всего таких путей: $ G[v] = \sum_{x \in Ch(v)} \limits {\Bigl(G[x] + S[x]\Bigl)}$.

3. Пути проходящие через вершину $ v $. Рассмотрим двух сыновей этой вершины: $ x $ и $ y $. Нам надо подсчитать все пути, которые поднимаются из поддерева $ x $ в $ v $ и затем опускаются в поддерево $ y $ и наоборот. То есть по каждому пути, оканчивающимся в вершине $ x $ мы пройдем столько раз сколько элементов в поддереве $ y $, следовательно таких путей будет $ G[x]S[y] $. Аналогично, если будем подниматься из поддерева $ y $. Также надо учитывать сколько раз мы проходим по ребрам, соединяющим вершины $ x $ $ v $ и $ y $ $ x $. Итого для двух вершин $ x $ и $ y $: $ G[x]S[y] + G[y]S[x] + 2S[x]S[y]  $, следовательно ( $ x,y \in Ch(v)$) $ H[v] = \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y] + G[y]S[x] + 2S[x]S[y]\Bigl)} $. Но такой подсчет испортит асимптотику до $ O(n^2) $. Заметим, что $ \sum_{x,y} \limits {\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} $. Но еще надо учесть, что $ x \ne y $, следовательно $ \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} $. Аналогично для $ S[x]S[y] $. Итак: $ H[v] = 2\biggl(\sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} \biggl) + 2\biggl(\sum_{x} \limits {S[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(S[x]S[x]\Bigl)} \biggl) $.

Ответ задачи: $ F[v] = \sum_{x \in Ch(v)} \limits F[x] + G[v] + H[v] $. Асимптотика каждого слагаемого равна $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=\O \left ( n \right )$, где $ n $ — число вершин в дереве, следовательно и время работы самого алгоритма $ \O \left (n \right ) $.

### Амортизированные оценки для ДП на дереве

Пусть какой-либо алгоритм на дереве работает за время $\O \left ( \left |Ch \left ( x \right) \right |^k \right )$ для вершины x, тогда время обработки им всего дерева не превышает $\O \left ( n^k \right )$:

**Доказательство.** $\forall x \in \left \\{ 1 \dots n \right \\}: \left | Ch(x) \right | \leqslant n$, поэтому $\sum_{x=1}^n \limits \left | Ch \left ( x \right ) \right |^k \leqslant \sum_{x=1}^n \limits | Ch \left ( x \right ) | \cdot n^{k-1}=n \cdot n^{k-1}=n^k$.

## ДП по подмноженствам

Рассмотрим множество элементов, занумерованных от ~0~ до ~N - 1~. Каждое подмножество этого множества можно закодировать последовательностью битов длины ~N~ (эту последовательность будем называть маской). Если ~i~-й бит маски равен ~1~, то ~i~-й элемент входит в подмножество, иначе - нет. Например, маска ~00010011~ означает, что в подмножестве находятся элементы ~0~, ~1~ и ~4~ из множества ~[0...7]~. Всего получается ~2N~ масок, задающих ~2N~ подмножеств. Каждая маска по сути является целым числом, записанном в двоичной системе счисления.

Метод состоит в том, чтобы каждой маске (а значит и каждому подмножеству) сопоставлять какое либо значение и, на основе уже просчитанных значений для некоторых масок, получать значения для других масок. Как правило, в процессе просчета из текущего подмножества ~A~ извлекается один элемент всеми допустимыми способами и из полученных подмножеств ~A1', A2', ... , Ak'~ получается значение для ~A~. Однако для этого все значения для ~Ai'~ уже должны быть вычислены. Поэтому требуется установить порядок, в котором будут просматриваться маски. Несложно понять, что перебор масок в порядке возрастания чисел, которыми и являются эти маски, нам подойдет.

Для дальнейшего повествования примем следующие обозначения:
~bit(i, mask)~ - ~i~-й бит маски ~mask~
~count(mask)~ - количество битов ~1~ в маске ~mask~
~first(mask)~ - наименьший номер бита ~1~ в маске ~mask~
~(a?b:c)~ - возвратить ~b~ если выполняется ~a~, или возвратить ~c~ в противном случае.
Элементами множества будут являться вершины графа. Для простоты мы будем считать, что граф является неориентированным. Модификация нижеприведенных алгоритмов для случая ориентированного графа предоставляется читателю.

### Нахождение кратчайшего гамильтонова пути

Пусть в графе ~G = (V, E)~ ~n~ вершин и каждое ребро ~(i, j) in E~ имеет некоторый вес ~d(i, j)~. Необходимо найти гамильтонов путь, сумма весов по ребрам которого минимальна.

Пусть ~dp[mask][i]~ обозначает длину кратчайшего гамильтонова пути подмножества вершин ~mask~, заканчивающегося в вершине ~i~.

Динамика считается по следующим соотношениям:

* ~dp[mask][i] = 0~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = min_(bit(j,mask)=1, (j,i) in E) {dp[mask xor 2^i][j] + d(j, i)}~, если ~count(mask) > 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = ooo~ во всех остальных случаях.

Теперь искомая минимальная длина пути ~p_(min) = min_(i in [0...n-1]) {dp[2^n - 1][i]}~. Если ~p_(min) = ooo~, то гамильтонова пути в графе, увы, нет. Восстановить сам путь несложно. Пусть минимальный путь заканчивается в вершине ~i~. Тогда ~j ne i~, для которого ~dp[2^n - 1][i] = dp[(2^n - 1) xor 2^i][j] + d(j, i)~, является предыдущей вершиной пути. Теперь удалим ~i~ из множества и только что описанным способом найдем вершину предыдущую к ~j~. Продолжая процесс пока не останется одна вершина, мы найдем весь гамильтонов путь.

Данное решение требует $\O(2^nn)$ памяти и $\O(2^nn^2)$ времени.

## ДП по профилю
