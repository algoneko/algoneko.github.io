# Динамика (часть 2)

> Это динамика. _(Один из советов с кф как решать задачи на командных одимпиадах)_

## ДП по поддеревьям

Главной особенностью динамического программирования по поддеревьям является необходимость учитывать ответы в поддеревьях, так как они могут влиять на ответы в других поддеревьях.

### Задача о паросочетании максимального веса в дереве

Пусть задано взвешенное дерево, с весами, обозначенными как $w_{i,j}$, где $i$ и $j$ — вершины дерева, соединённые ребром.. Необходимо составить такое паросочетание, чтобы суммарный вес всех рёбер, входящих в него, был максимальным.

Для решения данной задачи существует несколько алгоритмов. Например, [алгоритм Куна](match.html), который имеет верхнюю оценку порядка $\O \left ( n^3 \right )$. Но так как нам дано дерево, то можно использовать динамическое программирование, время работы алгоритма с которым улучшается до $\O \left ( n \right )$.

Обозначим $a[i]$ как паросочетание максимального веса в поддереве с корнем в $i$-той вершине, при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, входящей в поддерево $i$-ой вершины; аналогично $b[i]$ --- как паросочетание максимального веса в поддерева с корнем в $i$-той вершине, но только при этом $i$-тая вершина соединена ребром, входящим в паросочетание, с вершиной, не входящей в поддерево $i$-ой вершины; а $c[i]=\max \left ( a[i],b[i] \right )$, таким образом, ответ на задачу будет находиться в $c[root]$, где $root$ --- корень дерева. Идея динамического программирования здесь состоит в том, что для того, чтобы найти паросочетание максимального веса с корнем в вершине $i$, нам необходимо найти максимальное паросочетание для всех поддеревьев $i$-ой вершины.

Обозначим $Ch(x)$ --- как множество сыновей вершины $x$ и будем находить значения $a[x]$ и $b[x]$ следующим образом:

Если вершина $x$ --- лист, то $a[x]=b[x]=0$,

в противном же случае

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}  +\sum_{\substack{z \neq y\\z \in Ch(x)}} \limits \max \left ( a[z],b[z] \right )\right )$,
* $b[x]=\sum_{z \in Ch(x)} \limits \max \left ( a[z], b[z] \right )$

С учётом того, что $c[i]=\max \left ( a[i],b[i] \right )$, эти формулы можно переписать как

* $a[x]=\max_{y \in Ch(x)}\limits \left ( b[y]+w_{x,y}-c[y] \right )+b[x]$
* $b[x]=\sum_{z \in Ch(x)} \limits c[z]$.


Теперь оценим количество операций, необходимых нам для нахождения $c[root]$. Так как $c[i]=\max \left ( a[i],b[i] \right )$, то для вычисления $c[root]$ необходимо вычислить $a[root]$, $b[root]$. Для вычисления и того, и другого необходимо время порядка $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=O \left ( n \right )$, где $ n $ — число вершин в дереве.

```
// в основной процедуре вызываем dfs от корня(root), после этого ответ будет хранится в c[root]
function dfs(x: int, a: int[], b: int[], c: int[], w: int[][], Ch: int[]): 
    for (i : Ch[x])
        dfs(i, a, b, c, w, Ch)
        // по формуле выше, но без b[x] (прибавим его один раз в конце)
        a[x] = max(a[x], b[i] + w[x][i] - с[i])
        b[x] += с[i]
    // так как в a[x] пока что хранится только на сколько мы можем
    // увеличить ответ если будем использовать вершину x
    a[x] += b[x]
    c[x] = max(a[x], b[x])
```

### Задача о сумме длин всех путей в дереве

Найти сумму длин всех путей в дереве.

Решим эту задачу за $ O(n) $. Пусть задано подвешенное дерево. Рассмотрим количество путей для вершины $ v $. Во-первых, это пути не проходящие через эту вершину, то есть все пути между её сыновьями. Во-вторых, пути, которые оканчиваются вершиной $ v $. И в третьих, это пути проходящие через вершину $ v $, они начинаются из поддерева одного из сыновей этой вершины и заканчиваются в другом поддереве одного из сыновей вершины $ v $.

Теперь подсчитаем пути для каждого варианта. Обозначим $ S[v]\ - $ размер поддерева $ v $, $ F[v]\ - $ сумма длин всех путей вершины $ v $, $ G[v]\ - $ количество путей оканчивающихся вершиной $ v $, $ H[v]\ - $ количество путей проходящих через вершину $ v $. Если вершина $ u $ лист, то $ S[u] $ = 1, а $ G[u] $ = 0.

1. Пути не проходящие через эту вершину. Это просто сумма суммы длин для всех поддеревьев детей или $ \sum_{x \in Ch(v)} \limits F[x]$.

2. Пути оканчивающиеся в вершине $ v $. Рассмотрим ребро, соединяющее вершину $ v $ и одного ее сына, пусть это будет вершина $ g $. Переберем все пути, которые начинаются с этого ребра и идут вниз. Это будет сумма путей оканчивающихся в $ g + S[g] $, так как суммарная длина поддерева $ g $ уже сосчитана и каждый такой путь мы продлили ребром, соединяющим вершины $ v $ и $ g $. Всего таких путей: $ G[v] = \sum_{x \in Ch(v)} \limits {\Bigl(G[x] + S[x]\Bigl)}$.

3. Пути проходящие через вершину $ v $. Рассмотрим двух сыновей этой вершины: $ x $ и $ y $. Нам надо подсчитать все пути, которые поднимаются из поддерева $ x $ в $ v $ и затем опускаются в поддерево $ y $ и наоборот. То есть по каждому пути, оканчивающимся в вершине $ x $ мы пройдем столько раз сколько элементов в поддереве $ y $, следовательно таких путей будет $ G[x]S[y] $. Аналогично, если будем подниматься из поддерева $ y $. Также надо учитывать сколько раз мы проходим по ребрам, соединяющим вершины $ x $ $ v $ и $ y $ $ x $. Итого для двух вершин $ x $ и $ y $: $ G[x]S[y] + G[y]S[x] + 2S[x]S[y]  $, следовательно ( $ x,y \in Ch(v)$) $ H[v] = \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y] + G[y]S[x] + 2S[x]S[y]\Bigl)} $. Но такой подсчет испортит асимптотику до $ O(n^2) $. Заметим, что $ \sum_{x,y} \limits {\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} $. Но еще надо учесть, что $ x \ne y $, следовательно $ \sum_{x,y\ x \ne y} \limits{\Bigl(G[x]S[y]\Bigl)} = \sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} $. Аналогично для $ S[x]S[y] $. Итак: $ H[v] = 2\biggl(\sum_{x} \limits {G[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(G[x]S[x]\Bigl)} \biggl) + 2\biggl(\sum_{x} \limits {S[x]} \sum_{y} \limits {S[y]} - \sum_{x} \limits {\Bigl(S[x]S[x]\Bigl)} \biggl) $.

Ответ задачи: $ F[v] = \sum_{x \in Ch(v)} \limits F[x] + G[v] + H[v] $. Асимптотика каждого слагаемого равна $\O \left ( \sum_{x=1}^n \limits \left | Ch(x) \right | \right )=\O \left ( n \right )$, где $ n $ — число вершин в дереве, следовательно и время работы самого алгоритма $ \O \left (n \right ) $.

### Амортизированные оценки для ДП на дереве

Пусть какой-либо алгоритм на дереве работает за время $\O \left ( \left |Ch \left ( x \right) \right |^k \right )$ для вершины x, тогда время обработки им всего дерева не превышает $\O \left ( n^k \right )$:

**Доказательство.** $\forall x \in \left \\{ 1 \dots n \right \\}: \left | Ch(x) \right | \leqslant n$, поэтому $\sum_{x=1}^n \limits \left | Ch \left ( x \right ) \right |^k \leqslant \sum_{x=1}^n \limits | Ch \left ( x \right ) | \cdot n^{k-1}=n \cdot n^{k-1}=n^k$.

## ДП по подмноженствам

Рассмотрим множество элементов, занумерованных от ~0~ до ~N - 1~. Каждое подмножество этого множества можно закодировать последовательностью битов длины ~N~ (эту последовательность будем называть маской). Если ~i~-й бит маски равен ~1~, то ~i~-й элемент входит в подмножество, иначе - нет. Например, маска ~00010011~ означает, что в подмножестве находятся элементы ~0~, ~1~ и ~4~ из множества ~[0...7]~. Всего получается ~2N~ масок, задающих ~2N~ подмножеств. Каждая маска по сути является целым числом, записанном в двоичной системе счисления.

Метод состоит в том, чтобы каждой маске (а значит и каждому подмножеству) сопоставлять какое либо значение и, на основе уже просчитанных значений для некоторых масок, получать значения для других масок. Как правило, в процессе просчета из текущего подмножества ~A~ извлекается один элемент всеми допустимыми способами и из полученных подмножеств ~a_1, a_2, ..., a_k~ получается значение для ~A~. Однако для этого все значения для ~a_i~ уже должны быть вычислены. Поэтому требуется установить порядок, в котором будут просматриваться маски. Несложно понять, что перебор масок в порядке возрастания чисел, которыми и являются эти маски, нам подойдет.

TODO: разобраться, как в showdown + katex + asciimath сделать `A'`

Для дальнейшего повествования примем следующие обозначения:

* ~bit(i, mask)~ - ~i~-й бит маски ~mask~

* ~count(mask)~ - количество битов ~1~ в маске ~mask~

* ~first(mask)~ - наименьший номер бита ~1~ в маске ~mask~

* ~(a?b:c)~ - возвратить ~b~ если выполняется ~a~, или возвратить ~c~ в противном случае.

Элементами множества будут являться вершины графа. Для простоты мы будем считать, что граф является неориентированным. Модификация нижеприведенных алгоритмов для случая ориентированного графа предоставляется читателю.

### 1. Нахождение кратчайшего гамильтонова пути

Пусть в графе ~G = (V, E)~ ~n~ вершин и каждое ребро ~(i, j) in E~ имеет некоторый вес ~d(i, j)~. Необходимо найти гамильтонов путь, сумма весов по ребрам которого минимальна.

Пусть ~dp[mask][i]~ обозначает длину кратчайшего гамильтонова пути подмножества вершин ~mask~, заканчивающегося в вершине ~i~.

Динамика считается по следующим соотношениям:

* ~dp[mask][i] = 0~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = min_(bit(j,mask)=1, (j,i) in E) {dp[mask o+ 2^i][j] + d(j, i)}~, если ~count(mask) > 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = oo~ во всех остальных случаях.

Теперь искомая минимальная длина пути ~p_(min) = min_(i in [0...n-1]) {dp[2^n - 1][i]}~. Если ~p_(min) = oo~, то гамильтонова пути в графе, увы, нет. Восстановить сам путь несложно. Пусть минимальный путь заканчивается в вершине ~i~. Тогда ~j ne i~, для которого ~dp[2^n - 1][i] = dp[(2^n - 1) o+ 2^i][j] + d(j, i)~, является предыдущей вершиной пути. Теперь удалим ~i~ из множества и только что описанным способом найдем вершину предыдущую к ~j~. Продолжая процесс пока не останется одна вершина, мы найдем весь гамильтонов путь.

Данное решение требует $\O(2^nn)$ памяти и $\O(2^nn^2)$ времени.

### 2. Нахождение количества гамильтоновых путей

Пусть теперь у нас есть невзвешенный граф ~G = (V, E)~. Модифицируем предыдущий алгоритм. Пусть ~dp[mask][i]~ теперь означает количество гамильтоновых путей подмножества ~mask~, заканчивающихся в вершине ~i~. Динамика перепишется следующим образом:

* ~dp[mask][i] = 1~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = sum_(bit(j, mask) = 1, (j, i) in E) dp[mask o+ 2^i][j]~, если ~count(mask) > 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = 0~ во всех остальных случаях.

Ответом будет число ~sum_(i in [0...n-1]) dp[2^n-1][1]~.

Решение требует $\O(2^nn)$ памяти и $\O(2^nn^2)$ времени.

### 3. Нахождение количества простых цепей

Посчитаем динамику, указанную в предыдущем пункте. Ответом будет являться число ~1/2 sum_(i in [0...n-1], count(mask)>= 2) dp[mask][i]~. Коэффициент ~1 / 2~ необходим, поскольку каждую цепь мы учитываем 2 раза - в одном и обратном направлении. Так же следует отметить, что тут учтены только пути длины хотя бы 1. При желании можно к ответу добавить ~n~ путей длины 0.

Данное решение требует $\O(2^nn)$ памяти и $\O(2^nn^2)$ времени.

### 4. Проверка существования гамильтонова пути

Тут можно обойтись решением 2, заменив сумму на побитовое ИЛИ. Тогда ~dp[mask][i]~ будет содержать булево значение - существует ли в подмножестве ~mask~ гамильтонов путь, заканчивающийся в вершине ~i~. Сама динамика будет такая:

* ~dp[mask][i] = 1~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = OR_(bit(j,mask)=1, (j,i) in E) dp[mask o+ 2^i][j]~, если ~count(mask) > 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = 0~ во всех остальных случаях.

Это решение, как и решение 2, требует $\O(2^nn)$ памяти и $\O(2^nn^2)$ времени. Эту оценку можно улучшить, если изменить динамику следующим образом.

Пусть ~dp2[mask]~ хранит маску подмножества всех вершин, для которых существует гамильтонов путь в подмножестве ~mask~, заканчивающихся в этой вершине. Другими словами, сожмем предыдущую динамику: ~dp2[mask] = sum_(i in [0...n-1]) dp[mask][i] * 2^i~. Для графа ~G~ выпишем ~n~ масок ~M_i~, для каждой вершины задающие множество вершин, которые связаны ребром в данной вершиной. То есть ~M_i = sum_(j in [0...n-1]) 2^j * ((i,j)in E? 1:0)~.

Тогда динамика перепишется следующим образом:

* ~dp2[mask] = 2^i~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp2[mask] = sum_(i in [0...n-1]) 2^i * ((dp[mask o+ 2^i] and M_i) ne 0 ? 1 : 0)~, если ~count(mask) > 1~

* ~dp2[mask] = 0~ во всех остальных случаях.

Особое внимание следует уделить выражению ~dp[mask o+ 2^i] and M_i~. Первая часть выражения содержит подмножество вершин, для которых существует гамильтонов путь, заканчивающихся в соответствующих вершинах в подмножестве ~mask~ без вершины ~i~, а вторая - подмножество вершин, связанных с ~i~ ребром. Если эти множества пересекаются хотя бы по одной вершине (их and не равен 0), то, как нетрудно понять, в ~mask~ существует гамильтонов путь, заканчивающийся в вершине ~i~.

Окончательная проверка состоит в сравнении ~dp[2^n - 1]~ c 0.

Это решение использует $\O(2^n)$ памяти и имеет асимптотику $\O(2^nn)$.

### 5. Нахождение кратчайшего гамильтонова цикла

Поскольку нам безразлично с какой вершины начинаться цикл, пусть он начинается с вершины 0. Далее, воспользуемся решением 1 для подмножества вершин, видоизменив соотношения следующим образом:

* ~dp[1][0] = 0~

* ~dp[mask][i] = min_(bit(j,mask)=1, (j,i) in E) {dp[mask o+ 2^i][j] + d(j,i)}~, если ~i > 0~, ~bit(0, mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = oo~ во всех остальных случаях.

Таким образом, ~dp[mask][i]~ будет содержать длину кратчайшего гамильтонова пути от вершины 0 до вершины ~i~.

Искомый минимум нужно будет выбирать по формуле ~min_(i in [1...n-1], (i,0) in E) {dp[2^n - 1][i] + d(i, 0)}~. Если полученный минимум равен ~oo~, то искомого цикла не существует. Искомый цикл восстанавливается аналогично решению 1.

### 6. Нахождение количества гамильтоновых циклов

Используя идеи решений 5 и 2, можно получить динамику, считающую количество гамильтоновых циклов за время $\O(2^nn^2)$, использующее $\O(2^nn)$ памяти.

### 7. Нахождение количества простых циклов

Пусть ~dp[mask][i]~ означает количество гамильтоновых путей в подмножестве вершин ~mask~, начинающихся в вершине ~first(mask)~ и заканчивающихся в вершине ~i~. Переход динамики выглядит так:

* ~dp[mask][i] = 1~, если ~count(mask) = 1~ и ~bit(i, mask) = 1~

* ~dp[mask][i] = sum_(j in[0...n-1], (j,i) in E) dp[mask o+ 2^i][j]~, если ~count(mask) > 1~, ~bit(i, mask) = 1~ и ~i ne first(mask)~

* ~dp[mask][i] = 0~ иначе.

Ответом будет являться сумма ~1/2 sum_(i in [0...n-1], count(mask)>= 3, (first(mask), i) in E) dp[mask][i]~.

Это решение за время $\O(2^nn^2)$ и память $\O(2^nn)$.

### 8. Проверка существования гамильтонова цикла

Модифицируем решение 5 и, воспользовавшись приемом, описанном в решении 4, получим решение для этой задачи за время $\O(2^nn)$ и память $\O(2^n)$.

## ДП по профилю
