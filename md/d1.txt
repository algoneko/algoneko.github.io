# Динамика (часть 1)

> Это динамика. _(Один из советов с кф как решать задачи на командных одимпиадах)_

## Основы ДП

Рассмотрим такую задачу: найти N-е число Фибоначчи.

Числа Фибоначчи определяются так: $F_0 = 0, F_1 = 1, F_n = F_{n-2} + F_{n-1}$.

Эту задачу можно решить рекурсивно:

```cpp
void fibonacchi(int n) {
    if (n < 0) return -1;
    if (n < 2) return n;
    return fibonacchi(n - 2) + fibonacchi(n - 1);
}
```

Однако это будет работать долго. 20-е число посчитать еще можно будет, а 40-е число - нет. И не потому, что числа большие. А потому, что мы будем делать слишком много лишней работы. Число операций будет экспоненциально относительно $N$.
​
Почему? Потому что, чтобы посчитать N-е число, нам нужно будет независимо посчитать (N-1)-е число и (N-2)-е число, и это в минимум в два раза больше действий, чем нужно для (N-2). А значит, для подсчета N-го числа Фибоначчи необходимо 2 раза посчитать (N-2)-е число, и это занимает в два раза больше времени, а значит это хотя бы $2^\frac{N}{2}$ действий. 
​
Это очень долго и главное, что это легко исправляется. Давайте просто не считать лишних действий - если мы один раз посчитали $F_k$, то давайте запомним, чему оно равно, и в следующий раз, когда оно нам понадобится, мы используем его сразу. Удобнее всего сохранить числа Фибоначчи прямо в массиве:

```cpp
int fib[N];
fib[0] = fib[1] = 1;
for (int i = 2; i < N; i++) {
     fib[i] = fib[i - 2] + fib[i - 1];
}
```

Это и называется динамическим программированием (или динамикой, ДП). Основная идея состоит в том, чтобы
* свести задачу для $N$ к задаче для чисел, меньших, чем $N$ (с помощью формулы)
* хранить все ответы в массиве
* заполнить начало массива вручную (для которых формула не работает)
* обойти массив и заполнить ответы по формуле
* вывести ответ откуда-то из этого массива

## План ДП

Чтобы решить задачу по динамике вы должны ответить на 5 вопросов:
* Что лежит в массиве? (самый важный вопрос чаще всего)
* Как инициализировать начало массива?
* Как обходить массив? (чаще всего слева направо, но не всегда)
* Какой формулой считать элементы массива?
* Где в массиве лежит ответ?

## Одномерная динамика: кузнечик

Рассмотрим такую задачу:

Есть полоска $1\times N$, кузнечик стоит на первой клетке, он может прыгать вперед на 1, 2, 3 клетки. Сколько есть способов добраться от начальной клетки до последней?

Как решать такие задачи? Нужно придумать рекуррентную формулу, как ответ для N зависит от ответа для меньших чисел. 

Очень помогает посмотреть на маленькие числа (!! одна из самых важных идей для придумывания решений):

Пусть dp[x] - это количество способов добраться от 1 клетки до клетки номер x.

* dp[1] = 1 способ (стоять на месте)
* dp[2] = 1 способ ($1 \rightarrow 2$)
* dp[3] = 2 способа ($1 \rightarrow 2 \rightarrow 3$ и $1 \rightarrow 3$)
* dp[4] = 4 способа ($1 \rightarrow 2 \rightarrow 3 \rightarrow 4$ и $1 \rightarrow 3 \rightarrow 4$ и $1 \rightarrow 2 \rightarrow 4$ и $1 \rightarrow 4$)
* dp[5] = 7 способов ($1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5$ и $1 \rightarrow 3 \rightarrow 4 \rightarrow 5$ и $1 \rightarrow 2 \rightarrow 4 \rightarrow 5$ и $1 \rightarrow 4 \rightarrow 5$ и $1 \rightarrow 2 \rightarrow 3 \rightarrow 5$ и $1 \rightarrow 3 \rightarrow 5$ и $1 \rightarrow 2 \rightarrow 5$)

Дальше становится сложнее. Но можно заметить закономерность. А можно и не заметить, но зато если мы сейчас придумаем формулу, мы легко проверим, работает ли она. Заодно мы получили наши значения на маленьких числах, которые нам все равно понадобится вбить в программу.

Какой последний прыжок кузнечика в его пути до N-й клетки? Один из трех вариантов:
* $(N - 1) \rightarrow N$
* $(N - 2) \rightarrow N$
* $(N - 3) \rightarrow N$

То есть все пути до $N$ разбиваются на 3 группы. Причем мы знаем сколько путей в каждой группе. В первой из них ровно dp[N - 1] путей - столько путей идут до (N-1)-й клетки, и дальше идет еще один прыжок. Во второй и третьей группах поэтому тоже dp[N - 2] и dp[N-3] путей.

Так что формула получается такой: dp[N] = dp[N - 3] + dp[N - 2] + dp[N - 1]. 

Очень похоже на числа Фибоначчи, да?

```cpp
dp[1] = 1
dp[2] = 1
dp[3] = 2
for (int i = 4; i <= N; i++) {
    dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];
}
```

Давайте изменим немного задачу: Теперь некоторые из клеток закрыты. То есть нам известно про конкретные клетки, что на них кузнечик прыгать не может. Тогда задача все еще решается так же, только нужно убедиться, что dp[x] = 0 для всех запрещенных x!

Также немного перепишем код, чтобы не писать отдельно случаи для 2 и 3, а также чтобы не писать в формуле сумму трех чисел (а представьте, что в задаче не 3, а 100). Будем инициализировать только dp[1]. А ко всем следующим значениям dp[i] будет прибавлять dp[i - k], где k = 1, 2, 3. Причем, если i - k < 1, то мы будем игнорировать такие клетки, и этим самым мы избавились от необходимости прописывать ответ для dp[2] и dp[3].

```cpp
if (can[1]) { 
    dp[1] = 1;
}
for (int i = 2; i <= N; i++) {
    if (can(i)) {
        for (int k = 1; k <= 3; k++) {
            if (i - k >= 1) {
                dp[i] += dp[i - k];
            }
        }
    }
}
```

## Последовательности без 3 единиц подряд

**Условие:** Определите количество последовательностей из нулей и единиц длины $N$, в которых никакие три единицы не стоят рядом.

**Решение:** Давайте хранить в $dp[N]$ ровно число таких последовательностей длины $N$ (это первое, что должно приходить в голову).

Давайте посмотрим для начала для маленьких чисел:

* $dp[0] = 1 (\text{пустая последовательность})$
* $dp[1] = 2 (0, 1)$
* $dp[2] = 4 (00, 01, 10, 11)$
* $dp[3] = 7 (000, 001, 010, 011, 100, 101, 110)$
* $dp[4] = 13 (0000, 0001, 0010, 0011, 0100, 0101, 0110, 1000, 1001, 1010, 1011, 1100, 1101)$

Сходу закономерность можно не увидеть. Нужно догадаться сгруппировать эти числа по том, сколько в конце единичек. Например, для dp[4]:

* 0 единичек в конце: $0000, 0010, 0100, 0110, 1000, 1010, 1100$ - их ровно семь, как для $N=3$, потому что первые 3 числа могут быть любые (но без трех единиц подряд), а четвертое - 0
* 1 единичка в конце: $0001, 0101, 1001, 1101$ - их ровно четыре, как для $N=2$, потому что первые 2 числа могут быть любые (но без 3 единиц подряд), а два последних - 01
* 2 единички в конце: $0011, 1011$ - их ровно две, как для $N=1$, потому что первое число может быть любым (но без 3 единиц подряд), а три последних - 011

Так мы замечаем и доказываем формулу:
$dp[N] = dp[N-1] + dp[N-2] + dp[N-3]$

Теперь за $\O(N)$ ее легко посчитать.

## Двумерная динамика: черепашка

На каждой клетке двумерной таблички написано, сколько там лежит монет. Черепашка стоит в клетке $1 \times 1$ (верхней левой), и может двигаться только на одну клетку вниз, или на одну клетку вправо. Нужно найти максимальное число монет, которое может набрать черепашка по пути к нижней правой клетке $N \times M$.

Первое, что приходит в голову - это просто идти черепашкой в ту клетку из соседних, где лежит больше монет. К сожалению, эта жадная стратегия не всегда работает. Например, на такой доске жадная черепашка пошла бы по следу из единичек, хотя гораздо выгоднее пойти сначала по нулям, а потом найти там большие горстки монет (40, 70, 100):

```python
COINS = [
    [0,   1,   1,   1,   1,   1],
    [0,   0,   0,   0,   0,   1],
    [0,   40,  70,  0,   0,   1],
    [100, 0,   0,   0,   0,   1]
]
```

Тут нас снова спасает динамика. Давайте сводить задачу к предыдущей! Задачей назовем "сколько максимально монет можно набрать на пути от $0\times0$ до $i\times j$" (заменим 1-нумерацию на 0-нумерацию). Будем хранить это в двумерном массиве $dp$ в клетке $dp[i][j]$.

Сразу понятны некоторые свойства этого массива:
* Он размера $n \times m$
* $dp[0][0] = COINS[0][0]$
* ответ на всю задачу лежит в $dp[n - 1][m - 1]$

Но гораздо важнее придумать формулу для подсчета $dp[i][j]$ через предыдущие. Легко посчитать первую строку и первый столбец: 
* $dp[0][k] = dp[0][k - 1] + COINS[0][k]$
* $dp[k][0] = dp[k - 1][0] + COINS[k][0]$

Так как до этих клеток есть ровно один путь.

Но что делать, если есть много путей до клетки $dp[i][j]$? Снова разобьем их на на несколько групп в зависимости от последнего хода (! важный трюк, запомните). Последний ход был:
* либо из $[i][j - 1]$
* либо из $[i - 1][j]$

Поэтому формула для максимального числа монет такая: $dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + COINS[i][j]$.

Ну все, достаточно пройтись правильно по двумерному массиву (построчно сверху вних, а в каждой строке слева направо) и заполнить этот массив.

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        if (i == 0 && j == 0) {
            dp[0][0] = COINS[0][0];
        } else if (i == 0) {
            dp[0][j] = dp[0][j - 1] + COINS[0][j];
        } else if (j == 0) {
            dp[i][0] = dp[i - 1][0] + COINS[i][0];
        } else {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + COINS[i][j];
        }
    }
}
```

## Восстановление ответа

Восстановление ответа

Теперь мы умеем находить ответ в задачах на ДП, но в некоторых задачах нам также интересно как мы можем его получить, например в задаче про черепашку нам может быть интересен путь. Такую задачу называют восстановлением ответа в динамике.

Есть два способа, которыми можно это сделать.

1) Хранить в массив prev откуда ты пришел в эту клетку.

Когда мы выбираем максимум из левой и верхней клетки, мы на самом деле решаем, какой последний ход будет в оптимальном пути до этой клетки - сверху или слева, и берем ответ для той клетки, сложнный с монетами в этой клетке. Давайте координаты клетки, откуда мы пришли, хранить в массиве prev. Или, в данном случае, можно хранить не координаты а просто 1, если пришли слева, и 0, если пришли сверху.

```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        if (i == 0 && j == 0) {
            dp[0][0] = COINS[0][0];
            prev[0][0] = -1;
        }
        else if (i == 0) {
            dp[0][j] = dp[0][j - 1] + COINS[0][j];
            prev[0][j] = 0;
        }
        else if (j == 0) {
            dp[i][0] = dp[i - 1][0] + COINS[i][0];
            prev[i][0] = 1;
        }
        else {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + COINS[i][j];
            if (dp[i - 1][j] > dp[i][j - 1]) {
                prev[i][j] = 1;
            }
            else {
                prev[i][j] = 0;
            }
        }
    }
}
```

И, чтобы восстановить ответ, надо просто пройтись с конца по этим клеткам до самого начала, и развернуть получившуюся последовательность.

```cpp
while (i > 0 || j > 0) {
    if (prev[i][j] == 1) {
        i -= 1;
        answer_directions.push_back("DOWN");
    }
    else {
        j -= 1;
        answer_directions.push_back("RIGHT");
    }
    answer.push_back({i, j});
}
reverse(answer.begin(), answer.end());
reverse(answer_directions.begin(), answer_directions.end());
```

2) Вместо хранения массива prev догадаться по массиву dp, откуда именно черепашка пришла в эту клетку.

В данном примере это довольно легко. Если мы уже посчитали весь массив dp, то теперь можно начиная с конца легко понять, пришла черепашка туда сверху или слева в оптимальном маршруте - она пришла из клетки с максимальным числом монет.

```cpp
while (i > 0 || j > 0) {
    if (i != 0 && (j == 0 || dp[i - 1][j] > dp[i][j - 1])) {
        i -= 1;
        answer_directions.push_back("DOWN");
    } 
    else {
        j -= 1;
        answer_directions.push_back("RIGHT");
    }
    answer.push_back({i, j})
}
reverse(answer.begin(), answer.end());
reverse(answer_directions.begin(), answer_directions.end());
```

## Лесенки

Лесенкой называется набор кубиков, в котором каждый горизонтальный слой содержит меньше кубиков, чем слой под ним. Подсчитать количество различных лесенок, которые могут быть построены из N кубиков.

```
＊＊
＊＊＊
＊＊＊＊＊
＊＊＊＊＊＊＊＊
```

**Решение:**

Если считать, что $dp[N]$ - это число лесенок из $N$ кубиков, то никакой закономерности скорее всего найти не получится.

```
dp[1] = 1:
+－+
|＊|
+－+

dp[2] = 1:
+－－+
|＊＊|
+－－+

dp[3] = 2:
+－－+－－－+
|＊　|　　　|
|＊＊|＊＊＊|
+－－+－－－+

dp[4] = 2:
+－－－+－－－－+
|＊　　|　　　　|
|＊＊＊|＊＊＊＊|
+－－－+－－－－+

dp[5] = 2:
+－－－+－－－－－+
|＊＊　|　　　　　|
|＊＊＊|＊＊＊＊＊|
+－－－+－－－－－+

dp[6] = 3:
+－－－+－－－－+－－－－－－+
|＊　　|　　　　|　　　　　　|
|＊＊　|＊＊　　|　　　　　　|
|＊＊＊|＊＊＊＊|＊＊＊＊＊＊|
+－－－+－－－－+－－－－－－+
```


По числам построить закономерность сложно, и по самим лесенкам тоже. Не видно какого-то рассуждения вида "ко всем лесенкам размера ~N-1~ можно положить на любой слой еще один кубик", иногда ведь и нельзя.

Тут нам помогает введение дополнительного параметра. Нас просят решить одномерную задачу (для ~N~), а мы решим двумерную задачу для ~n~ и ~m~. Давайте зафиксируем размер самого нижнего слоя и назовем его размер ~m~.

То есть ~dp[n][m]=~ "число лесенок, состоящих из ~N~ кубиков, таких, что самый нижний слой состоит из ~M~ кубиков".

Как это связано с нашей задачей? Ответ на нашу задачу равен ~dp[N][1]+dp[N][2]+...+dp[N][N]~.

Какая есть формула для такой постановки задачи? Размер нижнего слоя у нас зафиксирован и равен ~m~, осталость ~n−m~ кубиков на верхних слоях. Логично перебрать размер второго снизу слоя, который может быть любым от ~1~ до ~m−1~: ~dp[n][m]=dp[n−m][1]+dp[n−m][2]+...+dp[n−m][m−1]~

Это все при условии, что ~n ge m~. Иначе ~dp[n][m]=0~.

Теперь осталось понять как инициализировать этот массив и аккуратно по нему пройтись. Давайте инициализируем его ровно для случая ~n=0~, ~m=0~: ~dp[0][0] = 1~.

Пройдемся по массиву сначала для всех ~m~ при ~n = 1~, потому для всех ~m~ при всех ~n = 2~ и так далее - то есть по строчкам обычными двумя циклами for.

Для ~m>0~ в ячейках ~dp[0][m]~ наш алгоритм будет работать и возвращать 0, так как ~n<m~.

Для всех ~n>0~ наша формула будет находить ответ через числа с меньшим ~n~, а значит алгоритм корректен.

Он заполняет табличку размера ~N^2~, обрабатывая каждую клетку за $\O(N)$ операций, итоговое время работы - $\O(N^3)$.

## Рюкзак

### 0-1 Рюкзак

В самой простой форме задача о рюкзаке формулируется так:

Даны $n$ предметов с весами $a_1,\dots, a_n$. Определите, на какой максимальный вес можно набрать предметов в рюкзак вместимости $W$.

Для решения этой задачи воспользуемся динамическим программированием. Обозначим за $dp[i][j]$ состояние, когда мы рассмотрели первые $i$ предметов и набрали ими $j$ веса. $dp[i][j]=True$, если такая ситуация возможна, иначе $dp[i][j]=False$.

Для каждого состояния $dp[i][j]$, которое возможно получить, мы можем либо взять предмет номер $i$ и попробовать обновить ответ из состояния $dp[i - 1][j - a[i]]$, либо не брать его и обновить ответ из $dp[i - 1][j]$. Очевидно, что мы можем получить 0 веса, рассмотрев 0 предметов.

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i - 1][j];
        if (a[i] <= j) {
            dp[i][j] = (dp[i][j] | dp[i - 1][j - a[i]]);
        }
    }
}
```

Ответом на задачу будет максимальное $n$, такое что $dp[n][j]$ равно $True$. Такое решение работает за $\O(nW)$.

**Уменьшаем затраты памяти.** Заметим, что на самом деле нам достаточно одномерно массива $dp[w]$, в котором мы будем хранить, можно ли набрать такой вес. Изначально там будут храниться нули, после чего мы будем по очереди добавлять предметы и пересчитывать значения массива, пытаясь набрать вес w, используя новый предмет, если конечно раньше мы не могли набрать вес w.

Работать такой алгоритм будет всё ещё за $\O(nW)$, поскольку мы для каждого предмета пытаемся перебрать все веса и пробуем этот вес набрать, используя этот предмет.

**Неасимптотически уменьшаем затраты времени.** Заметим, что нам нет необходимости каждый раз просматривать заново те веса, которые мы уже умеем набирать. Заведём изначально ещё дополнительный вектор $unreachable$ весов, которые мы не умеем набирать, изначально там все веса от $1$ до $W$ (нулевой вес мы всегда умеем набирать). На каждом шаге мы будем добавлять новый предмет и будем перебирать веса из $unreachable$, если его получилось набрать, то удаляем его из вектора: свапаем с последним элементом и делаем pop_back. Поскольку порядок весов в $unreachable$ нам неважен, мы можем спокойно переставлять элементы внутри него.

### Рюкзак со стоимостями предметов

Теперь у каждого предмета есть стоимость $c_i$. Надо набрать не как можно больший вес, а как можно бОльшую суммарную стоимость предметов так, чтобы предметы по весу влезли в рюкзак.

Изменим значение $dp[i][j]$. Пусть оно равно максимальной стоиомости предметов, которые можно набрать среди первых $i$ с суммарным весом $j$. Порядок пересчета динамики остается прежним, но меняется обновление состояния: если мы не берем текущий предмет, то ответ не хуже, чем для первых $i-1$ предмета. А если берем, то места на предыдущие предметы остается $j - a[i]$, но мы прибавляем стоимость нового предмета к ответу.

```cpp
dp[i][j] = dp[i - 1][j];
if (a[i] <= j) {
    dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i]] + c[i]);
}
```

Если так получилось, что веса большие, а стоимости маленькие, можно поменять их местами и считать минимальный вес при данной набранной стоимости. Поменять местами значение динамики и параметр — довольно распространенный трюк в динамическом программировании.

### Рюкзак с ограниченным числом предметов

Пусть, теперь предметов каждого типа может быть несколько, то есть даны не только веса и стоимости, но и максимальные количества каждого из предметов $k_1,\ldots,k_n$. Тогда для каждого состояния $dp[i][j]$ переберем, сколько мы взяли предметов такого типа и сделаем переход из каждого соответствующего состояния. Понятно, что мы не сможем взять более, чем $\lfloor\frac{W}{a_i}\rfloor$ предметов каждого типа.

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i - 1][j];
        if (a[i] <= j) {
            for (int cnt = 0; cnt <= k[i]; cnt++) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i] * cnt] + c[i] * cnt);
            }
        }
    }
}
```

Такое решение работает за $\O(nW^2)$, так как $k_i$ могут быть очень большими, а $a_1=1$. 

Можете попробовать решить эту задачу за $\O(nW\log K)$, где $K$ — максимальное из $k_i$. 

### Рюкзак с неограниченным числом предметов

Пусть, теперь каждого предмета будет не $k_i$, а вообще бесконечно. Оказывается, задача стала только проще. Вернемся к обычному рюкзаку с весами и стоимостями. Единственное отличие будет в том, что теперь мы можем делать второй переход не из предыдущей строки, а прямо из текущей. При этом заметим, что для каждого состояния достаточно рассмотреть взятие только одного предмета данного типа, поскольку взятие двух и более будет рассмотрено одновременно. 

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i - 1][j];
        if (a[i] <= j) {
            dp[i][j] = max(dp[i][j], dp[i][j - a[i]] + c[i]);
        }
    }
}
```

Такое решение работает за $\O(nW)$.

Если $W$ велико, а $a_i$ достаточно малы, можно построить решение за $\O(n + A^3)$, где $A$ — максимальное из $a_i$. Заметим, что если $W$ достаточно большое, то большая часть рюкзака будет занята предметами одного и того же типа с максимальной удельной стоимостью. Можно доказать, что одним и тем же предметом будет занято не менее $W-A^2$ веса. Таким образом, можно за $\O(n)$ выбрать предмет с максимальным удельным весом, а для оставшихся предметов запустить предыдущий алгоритм, который сработает за $\O(A^3)$, так как имеет смысл рассматривать не более $A$ предметов, а максимальный вес $A^2$.

### Восстановление ответа в рюкзаке
Во всех рассмотренных задачах восстановление ответа делается стандартным образом: нужно из ответа пройтись обратно до начала.

* первый способ - это построить массив prev, где для каждой ячейки $dp[i][j]$ хранить, берем мы предмет i, или не берем предмет $i$.
* второй способ - это определять это на ходу, смотря, какое из значений $dp[i - 1][j]$ или $dp[i - 1][j - a[i]] + c[i]$ больше.

## НВП

Пусть, дана последовательность из $n$ чисел $a_1,\ldots,a_n$. Требуется найти длину ее наибольшей возрастающей подпоследовательности (НВП, по английски будет GIS = Greatest Increasing Subsequence), то есть длину такой наибольшей последовательности индексов $i_1<i_2<\ldots<i_k$, что $a[i_1]<a[i_2]<\ldots<a[i_k]$. 

Пример: в последовательности $100, \underline{20}, \underline{75}, 0, -40, \underline{80}, -10, \underline{120}, 110$ наибольшей возрастающей подпоследовательность является $20, 75, 80, 120$: она имеет длину $4$. Возрастающих подпоследовательностей длины 5 здесь нет.

### НВП за $\O(N^2)$

Давайте решать наивно через динамическое программирование — то есть хранить в $dp[i]$ ровно то, что нам надо найти — длину НВП для первых $i$ чисел. 

$dp[0] = 0$. Но как найти формулу, выражающую $dp[i]$ через предыдущие значения?

Ну, есть два варианта:
* $i$-ое число не входит в НВП. Тогда $dp[i] = 1$
* $i$-ое число входит в НВП. Тогда $dp[i] = 1 + dp[k]$, где $k$ — индекс предыдущего числа в этой НВП. Так давайте просто его переберем. При этом надо учесть, что $a[k]$ должно быть меньше, чем $a[i]$!* $i$-ое число входит в НВП. Тогда $dp[i] = 1 + dp[k]$, где $k$ — индекс предыдущего числа в этой НВП. Так давайте просто его переберем. При этом надо учесть, что $a[k]$ должно быть меньше, чем $a[i]$!исло входит в НВП. Тогда $dp[i] = 1 + dp[k]$, где $k$ — индекс предыдущего числа в этой НВП. Так давайте просто его переберем. При этом надо учесть, что $a[k]$ должно быть меньше, чем $a[i]$

Итоговая формула получается такая:

$$dp[i] = \max(1, 1 + \max\limits_{k < i | a[k] < a[i]}dp[k])$$

Этот алгоритм работает за $\O(N^2)$: у нас $\O(N)$ состояний динамики, и каждое из них мы считаем за $\O(N)$ действий, пока ищем этот максимум.

Ответ восстанавливается тем же способом: для каждого состояния нужно сохранить, где был этот максимум — там и есть предыдущее число в НВП.

### НВП за $\O(N\log{N})$
Решим эту задачу чуть более нестандартным динамическим программированием, где $min\_end[i]$ будет обозначать минимальное число, на которое может заканчиваться НВП длины $i$. При этом мы будем постепенно обрабатывать числа слева направо, и в этом массиве будет храниться только информация про все НВП в уже обработанном начале последовательности.

Изначально $min\\_end[0]=-\infty, min\\_end[i]=\infty$ для $i>0$. В качестве $\infty$ надо выбрать число, которое заведомо больше любого из $a_i$, аналогично с $-\infty$.

Рассматривая очередной элемент, попробуем продлить им каждую подпоследовательность:

Ответом будет максимальный такой индекс $j$, что $min\\_end[j] \neq 0$. Это решение работает за $\O(n^2)$.

Его можно значительно ускорить, заметив два факта:
- На любом шаге $min\\_end[i-1]\leq min\\_end[i]$. Это легко доказать от противного.
- Из предыдущего факта следует, что любое $a[i]$ обновит максимум одно значение динамики, так как попадет максимум в один интервал.

Значит, для поиска $j$, которое обновится, можно воспользоваться бинарным поиском. Это решение уже работает за $\O(n\log n)$.

## НОП

Даны две последовательности $a_1,\ldots,a_n$ и $b_1,\ldots,b_m$. Требуется найти длину их наибольшей общей подпоследовательности (НОП, по английски будет GCS = Greatest Common Subsequence), то есть длину наибольшей таких последовательностей $i_1<\ldots<i_k$ и $j_1<\ldots<j_k$, что $a[i_1]=b[j_1],\ldots,a[i_k]=b[j_k]$.

Решим эту задачу с помощью динамического программирования, где $dp[i][j]$ будет обозначать длину НОП, если мы рассмотрели префиксы последовательностей длины $i$ и $j$.

Тогда заметим, что есть две ситуации, когда мы считаем $dp[i][j]$:
* $a_i \neq b_j$, тогда хотя бы один из этиз символов не содержится в НОП, иначе она заканчивается на два разных символа. В этом случае $dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$
* $a_i = b_j$, тогда несложно доказать, что точно есть максимальная НОП, в которую входят ОБА этих символа, а значит $dp[i][j] = 1 + dp[i - 1][j - 1]$.

А на пустых префиксах ответ 0.

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        if (a[i - 1] == b[j - 1]) {
            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
        }
    }
}
```

Ответом является максимальное число в массиве $dp$. Решение работает за $\O(nm)$.

Ответ при это восстанавливается классическим способом - с конца. Нам все еще нужно просто в каждой ячейке смотреть - если символы в ней равны, то нужно уменьшить $i$ и $j$, иначе только один из них - так, чтобы НОП был максимален.

## ДП по префиксу и последнему элементу

## Ленивая динамика

## Опять сжимаешь, шакал...

[NEERC 2002, Task F - Folding](https://acm.timus.ru/problem.aspx?num=1238)

### Условие задачи
Петя хочет сократить запись последовательности, состоящей из заглавных латинских букв. Для этого он может свернуть ее повторяющиеся подпоследовательности. Например, последовательность `AAAAAAAAAABABABCCD` может быть записана как `10(A)2(BA)B2(C)D`.

Формальной определение свернутой последовательности и соответствующей ей операции развертки дается следующим образом:

1. Последовательность, которая содержит единственный символ от `A` до `Z` представляет из себя свернутую последовательность. При развертке такой последовательности получается она сама.

2. Если `S` и `Q` — свернутые последовательности, то `SQ` также свернутая последовательность. Если при развертке строки `S` получается строка `S′`, а при развертке `Q` получается `Q′`, то при развертке `SQ` получается строка `S′Q′`.

3. Если `S` -- свернутая последовательность, то `X(S)` также свернутая последовательность, где `X` это десятичное представление целого числа большего единицы. Если при развертке строки `S` получается строка `S′`, то при развертке `X(S)` получается строка `S′`, повторенная `X` раз.

Петя хочет свернуть заданную последовательность таким образом, чтобы результат содержал наименьшее число символов.

Входной файл содержит непустую строку, состоящую из заглавных латинских букв. Длина строки не превышает 1000 символов.

В выходной файл выведите одну строку, содержащую наименьшую последовательность развертка которой даст строку, заданную во входном файле.

Если ответов несколько --- выведите любой из них.

### Решение
Давайте решим задачу с использованием динамического программирования. Пусть исходная строка `s`, а ее длина -- `n`.

Давайте в `DP[i][j]` хранить длину свернутой подстроки `[i; j]`. Тогда длина всей свернутой строки будет храниться в `DP[0][n - 1]`.

Давайте посчитаем `LCP[i][j]`: наибольший общий префикс суффиксов, которые начинаются с позиций i и j. Например, для строки `abcabc` `LCP[0][3] = 3`, т.к. там наибольший общий префикс это `abc`.

Как посчитать `LCP[i][j]`: Это `0`, если `s[i] != s[j]`, иначе `LCP[i][j] = 1 + LCP[i + 1][j + 1]`. Просчитывать `LCP[i][j]` будем для `i` от `n-1` до `0` и внутри для `j` от `n-1` до `0`.

Пересчет динамики здесь не сильно простой.

Будем перебирать длину исходной строки `len` `[1; n]`. Тогда для каждой подстроки `[left; left + len - 1]` будем считать динамику.

Пусть `right = left + len - 1`, тогда изначальное значение `DP[left][right]` будет равно длине сжимаемой строки, т.е. `len`.

Тогда сжать строку можно 2 способами:

1. Слепить 2 сжатые строки, получившиеся из подстрок меньшей длины

2. Повторить какую-то сжатую строку несколько раз

Подробнее:

Если мы получаем строку склеиваним других строк, то можно перебирать границу склейки `m` на `[left; right)`. Тогда для каждого такого `m` проверим, будет ли текущая сжатая строка (`DP[i][j]`) хуже новой (`DP[left][m] + DP[m+1][right]`). Если новая оказалась лучше, то заменяем `DP[i][j]`.

Если мы сжимаем строку путем повтора какого-то префикса, то давайте просто перебирать его. Пусть `pr` - длина части, которую мы хотим повторить; длина из несжатой строки!! Тогда если `len` делится на `pr`, то `pr` скорее всего будет префиксом строки.

Проверим этот факт. `pr` -- префикс подстроки `[left; right]`, если `LCP[left][left + pr] >= len - pr`. (Доказательства у меня нет, но можно спросить кого-нибудь).

Пусть мы знаем, что `pr` -- это префикс. Тогда надо понять, а улучшит ли он ситуацию. Длина новой строки будет равна `2 + to_string(len / pr).size() + DP[left][left + pr - 1]` (скобки + число_повторов + сжатая! строка).

Но это не все!

Задача требует не ДЛИНУ, а САМУ сжатую строку.

Сделаем "ход конем": заведем хитрый массив предков `Pred[i][j]` в котором сохраним спопоб получения сжатой строки `[i; j]`. По умолчанию заполнен 0.

Пусть `Pred[i][j] = 0`, если мы не сжали строку (то есть берем подстроку исходной строки).

Пусть `Pred[i][j] = k > 0`, тогда мы получили строку `[i; j]` сложением сжатых строк `[i; k - 1]` и `[k; j]`.

Пусть `Pred[i][j] = k < 0`, тогда мы получили строку `[i; j]` повторением строки `[i; i + k - 1]` `(j - i + 1)/-k` раз.

Тогда расставив `Prev[i][j] = ...` в пересчете динамики мы получим массив предков и возможность получить саму сжатую строку.

Но как восстановить ее по массиву предков?

Мне было лень писать нерекурсивную реализацию, поэтому я написал рекурсивную.

Напишем функцию `string unfold(int L, int R, string cur)`, которая будет разворачивать массив предков в сжатую строку. `cur` -- это текущая развернутая строка.

Пусть `prev = Pred[L][R]`. Тогда если `prev = 0`, то вернем `cur` + подстроку строки `s` с символа `L` размером `R - L + 1`: `cur + s.substr(L, R - L + 1)`.

Если `prev > 0`, то вернем сумму развернутых строк [L; L + prev - 1] и [L + prev; R], не забыв прибавить `cur`: `unfold(L + prev, R, unfold(L, L + prev - 1, cur))`.

Если `prev < 0`, то вернем строку вида `CX(A)`, где `C = cur`, `X = (R - L + 1)/-prev` и `A = unfold(L, L - prev - 1, "")`.

Остается только вывести `unfold(0, n - 1, "")` и задача решена.

### Код

Крайне не рекомендую использовать C-style динамические массивы!!!

```cpp
#define all(cont) cont.begin(), cont.end()
#define unwrap(pr) pr.first, pr.second
#define pridx(q, pr) q[pr.first][pr.second]

int *DP[1001], *Pr[1001];
unsigned short* LCP[1001];
string s;

string unfold(int L, int R, string cur) {
  const int prev = Pr[L][R];
  if (prev == 0) {
    return cur + s.substr(L, R - L + 1);
  }
  if (prev > 0) {
    // Splitted
    return unfold(L + prev, R, unfold(L, L + prev - 1, cur));
  }
  // Repeated
  return cur + to_string((R - L + 1) / -prev) + "(" +
         unfold(L, L - prev - 1, "") + ")";
}

int main() {
  cin >> s;
  int n = s.size();
  for (int i = 0; i < 1001; ++i) {
    DP[i] = (i < n ? new int[n] : nullptr);
    Pr[i] = (i < n ? new int[n] : nullptr);
    LCP[i] = (i <= n ? new unsigned short[n + 1] : nullptr);
    if (LCP[i]) {
      for (int j = 0; j <= n; ++j) {
        LCP[i][j] = 0;
      }
    }
    if (DP[i]) {
      for (int j = 0; j < n; ++j) {
        DP[i][j] = 0x1FFFFFFF;
        Pr[i][j] = 0;
      }
    }
  }

  for (int i = n - 1; i >= 0; --i) {
    for (int j = n - 1; j >= i; --j) {
      if (s[i] == s[j]) {
        LCP[i][j] = 1 + LCP[i + 1][j + 1];
      }
    }
  }

  for (int len = 1; len <= n; ++len) {
    for (int left = 0; left + len <= n; ++left) {
      int right = left + len - 1;  // [left; right]
      DP[left][right] = len;

      for (int m = left; m < right; ++m) {
        if (DP[left][right] > DP[left][m] + DP[m + 1][right]) {
          DP[left][right] = DP[left][m] + DP[m + 1][right];
          Pr[left][right] = m - left + 1;
        }
      }

      for (int pr = 1; pr < len; ++pr) {
        int lpr = len / pr;
        int len_cur = (lpr < 10 ? 1 : lpr < 100 ? 2 : lpr < 1000 ? 3 : 4);
        if (0 == len % pr && LCP[left][left + pr] >= len - pr) {
          if (DP[left][right] > 2 + len_cur + DP[left][left + pr - 1]) {
            DP[left][right] = 2 + len_cur + DP[left][left + pr - 1];
            Pr[left][right] = -pr;
          }
        }
      }
    }
  }

  cout << unfold(0, n - 1, "");

  return 0;
}
```
