# Куча

> Эта статья — о структуре данных в программировании. О динамической области распределения памяти см. [Динамически распределяемая память](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C).

**Куча** -- дерево, которое удовлетворяет __свойству кучи++: если $B$ является узлом-потомком узла $A$, то ~key[A] ge key[B]~. Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют `max`-кучами (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют `min`-кучами).

Над кучами обычно проводятся следующие операции:

*   __найти максимум__ или __найти минимум__: найти максимальный элемент в max-куче или минимальный элемент в min-куче, соответственно
*   __удалить максимум__ или __удалить минимум__: удалить корневой узел в max- или min-куче, соответственно
*   __увеличить ключ__ или __уменьшить ключ__: обновить ключ в max- или min-куче, соответственно
*   __добавить__: добавление нового ключа в кучу.
*   __слияние__: соединение двух куч с целью создания новой кучи, содержащей все элементы обеих исходных.

## Двоичная куча

Самая простая из всех видов куч. Двоичная куча является подвешенным деревом, для которого выполнены три условия:

1. Значение в любой вершине не меньше, чем значения её потомков. (Знак сравнения можно разворачивать или делать нестрогим)

2. У любой вершины не более 2 сыновей.

3. Слои заполняются последовательно слева направо сверху вниз.

![](img/Max-Heap.svg.png)

Давайте обозначим высоту кучи за $h$.

Куча также умеет 3 основные операции:

1. найти минимум за $\O(1)$

2. удалить минимум за $\O(h)$

3. добавление нового ключа в кучу за $\O(h)$

Так как куча всегда состоит из нескольких слоев заполненых полностью и одного частично и каждый слой содержит в два раза больше вершин, чем предыдущий, то можно понять, что высота дерева будет не больше $\O(\log N)$.

Теперь давайте поговорим о том, как же реализовать такую структуру.

Хранить кучу мы будем в виде массива, где у корня индекс равен 1, и у вершины $n$ индексы ее потомков - $2n$ и $2n+1$. [Ничего не напоминает?](st.html) Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются функцией Up.

Запускаемся из элемента $i$. Если элемент больше своего отца, то больше ничего делать не нужно. Иначе, мы меняем местами его с отцом и запускаемся от отца. В результате такой функции мы исправим случаи, когда первое условие кучи не соблюдается. Так как каждый раз мы только поднимаемся, то работать функция будет за количество предков вершины, а оно максимум равно высоте дерева.

```cpp
void Up(int i) {
    while (i > 1 && a[i] < a[i / 2]) {  // i = 1 — корень
        swap(a[i], a[i / 2]);
        i = i / 2;
    }
}
```

Если значение измененного элемента увеличивается, то свойства кучи восстанавливаются функцией Down. Запускаемя от элемента $i$, если $i$-й элемент меньше, чем его сыновья, всё поддерево уже является кучей, и делать ничего не надо. В противном случае меняем местами $i$-й элемент с наименьшим из его сыновей, после чего выполняем Down для этого сына. Так как каждый раз мы спускаемся только в одного сына, то работать функция будет за высоту дерева.

```cpp
void Down(int i) {
    while (2 * i < size) {  // size — количество элементов в куче
        int left = 2 * i;       // left — левый сын
        int right = 2 * i + 1;  // right — правый сын
        int j = left;
        if (right < size && a[right] < a[left]) {
            j = right;
        }
        if (a[i] <= a[j]) {
            break;
        }
        swap(a[i], a[j]);
        i = j;
    }
}
```

Первая операция -- просто обращение к `a[1]`.

Вторая операция -- забираем минимум из кучи, меняем его местами с последним элементом, затем просеиваем его вниз.

```cpp
// returns (new_pos_last; deleted_elem)
pair<int, int> Extract(vector<int> &heap) {
  pair<int, int> res = make_pair(-1, 0);
  if (heap.size() <= 1) {
    goto end;
  }
  res.second = heap[1];
  swap(heap[1], heap[heap.size() - 1]);
  heap.pop_back();
  if (heap.size() <= 1) {
    res.first = 0;
    goto end;
  }
  res.first = sift_down(1, heap);
end:
  return res;
}
```

Чтобы вставить элемент, допишем его в конец, затем будем просеивать его вверх.

```cpp
void insert(int what) {
  heap.push_back(what);
  sift_up(heap.size() - 1);
}
```

(Описать асимптотику построения и почему работает)

```cpp
void build() {
  for (int i = heap.size() / 2; i > 0; --i) {
    sift_down(i);
  }
}
```

## Другие виды куч

TODO
