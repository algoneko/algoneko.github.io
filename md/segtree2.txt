# Дерево отрезков снизу

Перед прочтением ознакомьтесь с [деревом отрезков](segtree.html).

Это --- перевод [поста с codeforces](https://codeforces.com/blog/entry/18051).

## ДО для изменения одного элемента

Деревья отрезков используются, если есть какой-то массив и требуется обрабатывать некоторые изменения и выполнять запросы на непрерывных отрезках. В первом примере запросы следующие:

1. Изменить элемент массива
2. Найти сумму на отрезке массива

### Полное двоичное дерево

![](img/segtree_ranges.png)

Запись на картинке имеет вид `node_index: отрезок [L; R)`. На нижней строке массив в 0-индексации --- листья дерева. Предположим, что массив имеет длину степени 2 (к примеру, 16), тогда мы получаем полное двоичное дерево. When going up the tree we take pairs of nodes with indices ~(2i, 2i+1)~ and combine their values in their parent with index ~i~. Таким образом, если поступает запрос суммы на полуинтервале `[3; 11)`, необходимо просуммировать значения в вершинах 19, 5, 12 и 26 (отмечены жирным), а не всех 8 листьев, попавших в диапазон. Давайте посмотрим на код, чтобы понять, _почему_ он работает.

```cpp
const int N = 1e5;  // Ограничение на размер
int n;  // истинный размер
int t[2 * N];

void build() {  // Построить дерево отрезков
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int p, int value) {  // Присвоить значение в точке
  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
}

int query(int l, int r) {  // сумма на полуинтервале [l, r)
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}

int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
  build();
  modify(0, 1);
  printf("%d\n", query(3, 11));
  return 0;
}
```

Вот и все. Полностью работающий пример. Забудь о рекурсивных функциях от 5 аргументах как страшный сон!

Теперь разберемся почему _это_ вообще работает, и работает эффективно.

1. По картинке видно, что листья хранятся одним сплошным списком начиная с индекса `n`, то есть элемент с номером `i` соответствует вершине с номером `n + i`. Таким образом, можно сразу считывать значения в листья ДО.

2. До обработки запросов необходимо построить дерево. Процедура простая и занимает $\O(n)$ времени. Поскольку нидекс родительской вершины меньше индексов дочерних, можно проходить все вершины в порядке уменишения их номера. Если битовые операции для вас --- черная магия, то код в `build()` эквивалентен `t[i] = t[2 * i] + t[2 * i + 1]`.

3. Изменение элемента тоже простое (последующий код позволит убедиться в этом) и время его работы пропорционально высоте дерева, то есть $\O(\log n)$. Нужно изменять только значения предков вершины. Таким образом, можно подняться по дереву до корня зная, что предок вершины `p` это `p / 2` (`p >> 1`), а `p ^ 1` меняет `2 * i` на `2 * i + 1` и наоборот, то есть показывает второго сына.

4. Нахождение суммы также работает за $\O(\log n)$. Чтобы лучше понять логику работы, можно просто рассмотреть пример `[3; 11)` и проверить, что результат получается из вершин 19, 26, 12, 5 именно в таком порядке.

Основная идея заключена в следующем. Если левая граница запроса нечетна (то есть если `l&1`), то `l` -- правый сын своего родителя. Это значит, что интервал включает `l`, но не включает его родителя. Тогда добавим `t[l]` в ответ и сдвинем границу вбок и вверх (`l = (l + 1) / 2`). Если `l` четно, что это левый сын и интервал включает в себя его родителя (пока конечно правая граница не мешает), так что можно просто перейти к предку (`l = l / 2`). Аналогичные рассуждения можно провести для правой границы. Останавливается алгоритм при совпадении левой и правой границ.

Никакой рекурсии. Не нужно вычисять середину интервала. Просто проход по всем затрагиваемым вершинам и ничего лишнего.

### Массив любой длины

К этому моменту были обсуждены массивы размера степени 2, так что ДО содержало все вершины. Следующий факт может вас шокировать, так что подготовьтесь.

> *Приведенный код работает для любой длины.*

Обхяснение этого факта сложнее, чем раньше, так что сначала поймем преимущества этого подхода.

1. ДО использует ровно ~2n~ памяти, а не ~4n~, как предлагают некоторые реализации (привет, е-маккс!).

2. Элементы массива хранятся сплошным массивом с индекса ~n~.

3. Все операци очень эффективны и легко пишкуся.

Следующую часть можно пропустить и просто протестировать код, проверив корректность. Но для тех, кому все-таки нужно объяснение, рассмотрим пример ~n = 13~.

![](img/segtree_ranges_2.png)

Теперь это не одно двоичное дерево, а лес из полных двоичных деревьев: корень 2 высота 4, корень 7 высота 2, корень 13 высота 1. Вершины, отмеченные черточками на картинке вообще никогда не учавствуют в запросах, так что там может быть что угодно. Хоть листья и находятся на разной высоте, это исправимо: режем дерево перед 13-й вершиной и приставляем правую часть слева. I believe the resulting structure can be shown to be isomorphic to a part of larger perfect binary tree with respect to operations we perform, and this is why we get correct results.

Формального доказательства не будет, просто покажем на примере. Рассмотрим интервал `[0; 7)`. Изначально `l = 13, r = 20`, `l&1 => add t[13]` и границы смещаются на `l = 7, r = 10`. Снова `l&1 => add t[7]`, границы смещаются на `l = 4, r = 5`, вершины на одной высоте. Теперь `r&1 => add t[4 = --r]`, границы переходят на `l = r = 2`, алгоритм заканчивается.

### Изменение на отрезке, значение в точке
