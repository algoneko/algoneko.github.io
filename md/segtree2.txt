# Дерево отрезков снизу

Перед прочтением ознакомьтесь с [деревом отрезков](segtree.html). Это перевод [поста с codeforces](https://codeforces.com/blog/entry/18051).

## ДО для изменения одного элемента

Деревья отрезков используются, если есть какой-то массив и требуется обрабатывать некоторые изменения и выполнять запросы на непрерывных отрезках. В первом примере запросы следующие:

1. Изменить элемент массива
2. Найти сумму на отрезке массива

### Полное двоичное дерево

![](img/segtree_ranges.png)

Запись на картинке имеет вид `node_index: отрезок [L; R)`. На нижней строке массив в 0-индексации --- листья дерева. Предположим, что массив имеет длину степени 2 (к примеру, 16), тогда мы получаем полное двоичное дерево. When going up the tree we take pairs of nodes with indices ~(2i, 2i+1)~ and combine their values in their parent with index ~i~. Таким образом, если поступает запрос суммы на полуинтервале `[3; 11)`, необходимо просуммировать значения в вершинах 19, 5, 12 и 26 (отмечены жирным), а не всех 8 листьев, попавших в диапазон. Давайте посмотрим на код, чтобы понять, _почему_ он работает.

```cpp
const int N = 1e5;  // Ограничение на размер
int n;  // истинный размер
int t[2 * N];

void build() {  // Построить дерево отрезков
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int p, int value) {  // Присвоить значение в точке
  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
}

int query(int l, int r) {  // сумма на полуинтервале [l, r)
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}

int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
  build();
  modify(0, 1);
  printf("%d\n", query(3, 11));
  return 0;
}
```

Вот и все. Полностью работающий пример. Забудь о рекурсивных функциях от 5 аргументах как страшный сон!

Теперь разберемся почему _это_ вообще работает, и работает эффективно.

1. По картинке видно, что листья хранятся одним сплошным списком начиная с индекса `n`, то есть элемент с номером `i` соответствует вершине с номером `n + i`. Таким образом, можно сразу считывать значения в листья ДО.

2. До обработки запросов необходимо построить дерево. Процедура простая и занимает $\O(n)$ времени. Поскольку нидекс родительской вершины меньше индексов дочерних, можно проходить все вершины в порядке уменишения их номера. Если битовые операции для вас --- черная магия, то код в `build()` эквивалентен `t[i] = t[2 * i] + t[2 * i + 1]`.

3. Изменение элемента тоже простое (последующий код позволит убедиться в этом) и время его работы пропорционально высоте дерева, то есть $\O(\log n)$. Нужно изменять только значения предков вершины. Таким образом, можно подняться по дереву до корня зная, что предок вершины `p` это `p / 2` (`p >> 1`), а `p ^ 1` меняет `2 * i` на `2 * i + 1` и наоборот, то есть показывает второго сына.

4. Нахождение суммы также работает за $\O(\log n)$. Чтобы лучше понять логику работы, можно просто рассмотреть пример `[3; 11)` и проверить, что результат получается из вершин 19, 26, 12, 5 именно в таком порядке.

Основная идея заключена в следующем. Если левая граница запроса нечетна (то есть если `l&1`), то `l` -- правый сын своего родителя. Это значит, что интервал включает `l`, но не включает его родителя. Тогда добавим `t[l]` в ответ и сдвинем границу вбок и вверх (`l = (l + 1) / 2`). Если `l` четно, что это левый сын и интервал включает в себя его родителя (пока конечно правая граница не мешает), так что можно просто перейти к предку (`l = l / 2`). Аналогичные рассуждения можно провести для правой границы. Останавливается алгоритм при совпадении левой и правой границ.

Никакой рекурсии. Не нужно вычисять середину интервала. Просто проход по всем затрагиваемым вершинам и ничего лишнего.

### Массив любой длины

К этому моменту были обсуждены массивы размера степени 2, так что ДО содержало все вершины. Следующий факт может вас шокировать, так что подготовьтесь.

> *Приведенный код работает для массивов любой длины.*

Обхяснение этого факта сложнее, чем раньше, так что сначала поймем преимущества этого подхода.

1. ДО использует ровно ~2n~ памяти, а не ~4n~, как предлагают некоторые реализации (привет, е-маккс!).

2. Элементы массива хранятся сплошным массивом с индекса ~n~.

3. Все операции очень эффективны и легко пишкуся.

Следующую часть можно пропустить и просто протестировать код, проверив корректность. Но для тех, кому все-таки нужно объяснение, рассмотрим пример ~n = 13~.

![](img/segtree_ranges_2.png)

Теперь это не одно двоичное дерево, а лес из полных двоичных деревьев: корень 2 высота 4, корень 7 высота 2, корень 13 высота 1. Вершины, отмеченные черточками на картинке вообще никогда не учавствуют в запросах, так что там может быть что угодно. Хоть листья и находятся на разной высоте, это исправимо: режем дерево перед 13-й вершиной и приставляем правую часть слева. I believe the resulting structure can be shown to be isomorphic to a part of larger perfect binary tree with respect to operations we perform, and this is why we get correct results.

Формального доказательства не будет, просто покажем на примере. Рассмотрим интервал `[0; 7)`. Изначально `l = 13, r = 20`, `l&1 => add t[13]` и границы смещаются на `l = 7, r = 10`. Снова `l&1 => add t[7]`, границы смещаются на `l = 4, r = 5`, вершины на одной высоте. Теперь `r&1 => add t[4 = --r]`, границы переходят на `l = r = 2`, алгоритм заканчивается.

### Изменение на отрезке, значение в точке

Некоторым приходят в голову очень сложные идеи, если поменять запросы местами, к примеру

1. Добавить значение ко всем элементам на отрезке

2. Найти значение определенного элемента

Но все, что нужно сделать, это поменять `modify` и `query`:

```cpp
void modify(int l, int r, int value) {
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) t[l++] += value;
    if (r&1) t[--r] += value;
  }
}

int query(int p) {
  int res = 0;
  for (p += n; p > 0; p >>= 1) res += t[p];
  return res;
}
```

Идея этого кода в том, что теперь мы храним изменения между соседними элементами, а не сам массив, поэтому значение элемента это префсумма.

Если надо просмотреть весь массив, то надо пропушить все изменения в листья. Такой код позволит получить все элементы за $\O(n)$, а не $\O(n\log n)$ так же, как и использование `build` вместо `n` запросов обновления.

```cpp
void push() {
  for (int i = 1; i < n; ++i) {
    t[i<<1] += t[i];
    t[i<<1|1] += t[i];
    t[i] = 0;
  }
}
```

Однако стоит признать, что подобный код работает, если порядок изменений отдельного элемента не влияет на конечный результат. К примеру, присваивание этому условию не удовлетворяет. Подробнее этот случай будет рассмотрен в разделе "Отложенные операции".

### Некоммутативные комбинаторы

Был рассмотрен очень простой комбинатор -- сложение. Он является коммутативным, то есть обладает переместительным свойством: ~a + b = b + a~. То же самое применимо к умножению, $\gcd$, $\min$, $\max$, так что можно просто заменить все вхождения `+` на любую из этих функций и все будет работать. Самое главное, не забыть сменить нейтральный элемент.

Но в реальном мире существуют задачи с неассоциативными комбинаторами, как к примеру [380C Серёжа и скобочки](https://codeforces.com/contest/380/problem/C). К счастью, данная реализация легко поддерживает такое изменение. Определим структуру `S` и функцию-комбинатор `S combine(S, S)` для нее. В `build` просто заменяем `+` на эту функцию. В `modify` требуется соблюдать правильный порядок детей, зная, что у левого сына четный индекс. В ответе на запрос левая граница идет слева направо, а правая --- справа налево, и в коде выглядеть это будет так:

```cpp
void modify(int p, const S& value) {
  for (t[p += n] = value; p >>= 1; ) t[p] = combine(t[p<<1], t[p<<1|1]);
}

S query(int l, int r) {
  S resl, resr;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) resl = combine(resl, t[l++]);
    if (r&1) resr = combine(t[--r], resr);
  }
  return combine(resl, resr);
}
```

## Отложенные операции

Отложенные операции позволяют отвечать на запросы на отрезках и делать изменения ан отрезках. Для начала, введем немного переменных:

```cpp
int h = sizeof(int) * 8 - __builtin_clz(n);  // h = log2(n)
int d[N]; 
```

`h` -- высота дерева, то есть наибольший единичный бит в `n`. `d[i]` это список отложенных операций, которые необходимо протолкнуть в детей вершины `i` при надобности (из примеров станет понятнее). Размер массива только `N`, поскольку у листьев нет детей. Итого потребление памяти составляет ~3n~.

Ранее было сказано, что `t[i]` соответствует значению функции на своем отрезке. Теперь это не совсем так -- сначала нужно применить все отложенные операции на пути от вершины `i` до корня. Будем предполагать, что `t[i]` уже включает `d[i]`, так что путь начинается не с `i`, а с его непосредственного предка.

Вернемся к примеру с промежутком ~[3; 11)~, но теперь нам нужно обновить на нем все элементы. Чтобы это сделать, изменим значения `t[i]` и `d[i]` в вершинах 19, 5, 12 и 26. Далее, если, к примеру, надо получить значение в вершине 22, нам нужно протолкнуть изменения с вершины 5. Заметим также, что операции изменения могут менять значения `t[i]` у своих предков: вершина 19 затрагивает вершины 9, 4, 2 и 1, а вершина 5 -- вершины 2 и 1. Следующий факт критичен для оценки асимптотики:

> Изменения на интервале ~[l; r)~ затрагивают значения `t[i]` только у родителей крайних листов (`l+n` и `r+n-1`), except the values that compose the interval itself — the ones accessed in _for_ loop.

Доказательство простое: при передвижении левой границы вершина, которую мы изменяем в цикле, всегда правый сын своего предка. Значит, все предыдущие моджификации были сделаны в поддереве левого сына того же предка, иначе мы бы обработали предка, а не обоих его сыновей. Это значит, что такущий непосредственный предок также является одним из предков листа `l+n`. Аналогичные рассуждения для правой границы верны.

Хватит пустых слов, пришло время конкретных примеров с кодом.

### Инкремент на отрезке, запрос максимума

Возможно, это самый простой случай. Представленный ниже код далек от универсаньности и не самый эффективный, но с него можно начать.

```cpp
void apply(int p, int value) {
  t[p] += value;
  if (p < n) d[p] += value;
}

void build(int p) {
  while (p > 1) p >>= 1, t[p] = max(t[p<<1], t[p<<1|1]) + d[p];
}

void push(int p) {
  for (int s = h; s > 0; --s) {
    int i = p >> s;
    if (d[i] != 0) {
      apply(i<<1, d[i]);
      apply(i<<1|1, d[i]);
      d[i] = 0;
    }
  }
}

void inc(int l, int r, int value) {
  l += n, r += n;
  int l0 = l, r0 = r;
  for (; l < r; l >>= 1, r >>= 1) {
    if (l&1) apply(l++, value);
    if (r&1) apply(--r, value);
  }
  build(l0);
  build(r0 - 1);
}

int query(int l, int r) {
  l += n, r += n;
  push(l);
  push(r - 1);
  int res = -2e9;  // лучше конечно писать INT_MIN
  for (; l < r; l >>= 1, r >>= 1) {
    if (l&1) res = max(res, t[l++]);
    if (r&1) res = max(t[--r], res);
  }
  return res;
}
```

Проанализируем код по функциям. Первые три являются вспомогательными, о которых вызывающая программа не должна ничего знать.

1. У нас есть два значения для каждой вершины, поэтому хорошо бы написать функцию, применяющую (`apply`) изменения каждой из них. `p < n` значит, что `p` не лист. Важное свойство максимума: если все значения на отрезке увелисить на определенное значение, то и максимум увеличится на это значение.

2. `build` обновляет всех предков вершины.

3. `push` проталкивает изменения из всех предков вершины начиная с корня. Эти предки в точности являются единицами в двоичной записи числа `p`, поэтому побитовые сдвиги используются при их расчете.

Теперь время посмотерть на основные функции.

1. `inc`: обработаем запрос инкремента знакомым циклом, а затем обновим всё, что осталось вызовами `build`.

2. `query`: Чтобы ответить на запрос, воспользуемся предыдущим циклом, но перед ним необходимо протолкнуть изменения в те вершины, которые мы будем использовать. Также как и в `build`, Достаточно просто протолкнуть изменения от предков в граничные листы.

Легко заметить, что все операции выполняются за время $\O(\log n)$.

Этот случай простой, поскольку

1. Порядок изменений не затрагивает их результат (коммутативность комбинатора)

2. При обновлении вершины нет необходимости знать о длине отрезка вершины.

Следующий пример покажет, как это всё учесть.

### Присваивание на отрезке, запрос суммы

Пример вдохновлен задачей [Timus 2042](http://acm.timus.ru/problem.aspx?space=1&num=2042).

И снова начнём со вспомогательных функций.

```cpp
void calc(int p, int k) {
  if (d[p] == 0) t[p] = t[p<<1] + t[p<<1|1];
  else t[p] = d[p] * k;
}

void apply(int p, int value, int k) {
  t[p] = value * k;
  if (p < n) d[p] = value;
}
```

Это просто функции, которые за $\O(1)$ вычисляют значение в вершине `p` и применяют к ней отложенные операции. Но кое-что нужно помнить:

1. Предполагается, что существует значение, никогда не используемое для изменения, в нашем случае это 0. Если такого значения не существует, просто сделайте дополнительный bool-массив и пользуйтесь им вместо `d[p] == 0` для проверки наличия изменений.

2. Появился дополнительный параметр `k`, обозначающий длину отрезка вершины. We will use this name consistently in the code to preserve this meaning. Очевидно, что нельзя посчитать сумму на отрезке без знания длины этого отрезка. Можно не передавать длину отрезка в функцию, а, к примеру, вычислять его на лету из индекса верштины или вообще сохранить все длины отрезков в специальный массив, но они все затратны по времени или памяти.

Далее потребуется обновить методы `build` и `push`. У нас было две версии этих методов -- одна за $\O(n)$ проходит всё дерево, другая за $\O(\log n)$ проходит всех предков листа. Эти две функции можно объединить и получить даже больше:

```cpp
void build(int l, int r) {
  int k = 2;
  for (l += n, r += n-1; l > 1; k <<= 1) {
    l >>= 1, r >>= 1;
    for (int i = r; i >= l; --i) calc(i, k);
  }
}

void push(int l, int r) {
  int s = h, k = 1 << (h-1);
  for (l += n, r += n-1; s > 0; --s, k >>= 1)
    for (int i = l >> s; i <= r >> s; ++i) if (d[i] != 0) {
      apply(i<<1, d[i], k);
      apply(i<<1|1, d[i], k);
      d[i] = 0;
    }
}
```

Обе функции работают за ~\O( log(n) + |r-l| )~. Если нужно изменить какой-то промежуток на дереве, то можно написать что-то типа


```cpp
push(l, r);
...  // делаем что угодно с элементами из промежутка [l, r)
build(l, r);
```

Как работают эти функции? Сначала исходный промежуток переходит в отрезок ~[l+n;r+n-1]~, чтобы можно было верно вычислять предков. Так как они проходят дерево по уровням, то легко поддерживать длину отрезка, которая всегда является степенью 2. `build` проходит снизу вверх, поэтому изначально ~k = 2~ (не 1, так как для листьев не надо ничего делать) и удваивается с каждым уровнем. `push` проходит сверху вниз, так что ~k = 2^h~ (то есть зависит от высоты дерева) и делится пополам на каждом уровне.

Основные функции...
