# Дерево отрезков снизу

Перед прочтением ознакомьтесь с [деревом отрезков](segtree.html).

Это --- перевод [поста с codeforces](https://codeforces.com/blog/entry/18051).

## ДО для изменения одного элемента

Деревья отрезков используются, если есть какой-то массив и требуется обрабатывать некоторые изменения и выполнять запросы на непрерывных отрезках. В первом примере запросы следующие:

1. Изменить элемент массива
2. Найти сумму на отрезке массива

### Полное двоичное дерево

![](img/segtree_ranges.png)

Запись на картинке имеет вид `node_index: отрезок [L; R)`. На нижней строке массив в 0-индексации --- листья дерева. Предположим, что массив имеет длину степени 2 (к примеру, 16), тогда мы получаем полное двоичное дерево. When going up the tree we take pairs of nodes with indices ~(2i, 2i+1)~ and combine their values in their parent with index ~i~. Таким образом, если поступает запрос суммы на полуинтервале `[3; 11)`, необходимо просуммировать значения в вершинах 19, 5, 12 и 26 (отмечены жирным), а не всех 8 листьев, попавших в диапазон. Давайте посмотрим на код, чтобы понять, _почему_ он работает.

```cpp
const int N = 1e5;  // Ограничение на размер
int n;  // истинный размер
int t[2 * N];

void build() {  // Построить дерево отрезков
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int p, int value) {  // Присвоить значение в точке
  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
}

int query(int l, int r) {  // сумма на полуинтервале [l, r)
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}

int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
  build();
  modify(0, 1);
  printf("%d\n", query(3, 11));
  return 0;
}
```

Вот и все. Полностью работающий пример. Забудь о рекурсивных функциях от 5 аргументах как страшный сон!

Теперь разберемся почему _это_ вообще работает, и работает эффективно.

1. По картинке видно, что листья хранятся одним сплошным списком начиная с индекса `n`, то есть элемент с номером `i` соответствует вершине с номером `n + i`. Таким образом, можно сразу считывать значения в листья ДО.

2. До обработки запросов необходимо построить дерево. Процедура простая и занимает $\O(n)$ времени. Поскольку нидекс родительской вершины меньше индексов дочерних, можно проходить все вершины в порядке уменишения их номера. Если битовые операции для вас --- черная магия, то код в `build()` эквивалентен `t[i] = t[2 * i] + t[2 * i + 1]`.

3. Изменение элемента тоже простое (последующий код позволит убедиться в этом) и время его работы пропорционально высоте дерева, то есть $\O(\log n)$. Нужно изменять только значения предков вершины. Таким образом, можно подняться по дереву до корня зная, что предок вершины `p` это `p / 2` (`p >> 1`), а `p ^ 1` меняет `2 * i` на `2 * i + 1` и наоборот, то есть показывает вторую дочернюю вершину.

4. Нахождение суммы также работает за $\O(\log n)$. Чтобы лучше понять логику работы, можно просто рассмотреть пример `[3; 11)` и проверить, что результат получается из вершин 19, 26, 12, 5 именно в таком порядке.

Основная идея заключена в следующем. If l, the left interval border, is odd (which is equivalent to l&1) then l is the right child of its parent. Then our interval includes node l but doesn't include it's parent. So we add t[l] and move to the right of l's parent by setting l = (l + 1) / 2. If l is even, it is the left child, and the interval includes its parent as well (unless the right border interferes), so we just move to it by setting l = l / 2. Similar argumentation is applied to the right border. We stop once borders meet.

Никакой рекурсии. Не нужно вычисять середину интервала. Просто проход по всем затрагиваемым вершинам и ничего лишнего.

### Массив любой длины
