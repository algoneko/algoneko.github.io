# Дерево отрезков снизу

Перед прочтением ознакомьтесь с [деревом отрезков](segtree.html).

Это --- перевод [поста с codeforces](https://codeforces.com/blog/entry/18051).

## ДО для изменения одного элемента

Деревья отрезков используются, если есть какой-то массив и требуется обрабатывать некоторые изменения и выполнять запросы на непрерывных отрезках. В первом примере запросы следующие:

1. Изменить элемент массива
2. Найти сумму на отрезке массива

### Полное двоичное дерево

![](img/segtree_ranges.png)

Запись на картинке имеет вид `node_index: отрезок [L; R)`. На нижней строке массив в 0-индексации --- листья дерева. Предположим, что массив имеет длину степени 2 (к примеру, 16), тогда мы получаем полное двоичное дерево. When going up the tree we take pairs of nodes with indices ~(2i, 2i+1)~ and combine their values in their parent with index ~i~. Таким образом, если поступает запрос суммы на полуинтервале `[3; 11)`, необходимо просуммировать значения в вершинах 19, 5, 12 и 26 (отмечены жирным), а не всех 8 листьев, попавших в диапазон. Давайте посмотрим на код, чтобы понять, _почему_ он работает.

```cpp
const int N = 1e5;  // Ограничение на размер
int n;  // истинный размер
int t[2 * N];

void build() {  // Построить дерево отрезков
  for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
}

void modify(int p, int value) {  // Присвоить значение в точке
  for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
}

int query(int l, int r) {  // сумма на полуинтервале [l, r)
  int res = 0;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) res += t[l++];
    if (r&1) res += t[--r];
  }
  return res;
}

int main() {
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
  build();
  modify(0, 1);
  printf("%d\n", query(3, 11));
  return 0;
}
```

Вот и все. Полностью работающий пример. Забудь о рекурсивных функциях от 5 аргументах как страшный сон!

Теперь разберемся почему _это_ вообще работает, и работает эффективно.

1. По картинке видно, что листья хранятся одним сплошным списком начиная с индекса `n`, то есть элемент с номером `i` соответствует вершине с номером `n + i`. Таким образом, можно сразу считывать значения в листья ДО.

2. До обработки запросов необходимо построить дерево. Процедура простая и занимает $\O(n)$ времени. Поскольку нидекс родительской вершины меньше индексов дочерних, можно проходить все вершины в порядке уменишения их номера. Если битовые операции для вас --- черная магия, то код в `build()` эквивалентен `t[i] = t[2 * i] + t[2 * i + 1]`.

3. Изменение элемента тоже простое (последующий код позволит убедиться в этом) и время его работы пропорционально высоте дерева, то есть $\O(\log n)$. Нужно изменять только значения предков вершины. Таким образом, можно подняться по дереву до корня зная, что предок вершины `p` это `p / 2` (`p >> 1`), а `p ^ 1` меняет `2 * i` на `2 * i + 1` и наоборот, то есть показывает второго сына.

4. Нахождение суммы также работает за $\O(\log n)$. Чтобы лучше понять логику работы, можно просто рассмотреть пример `[3; 11)` и проверить, что результат получается из вершин 19, 26, 12, 5 именно в таком порядке.

Основная идея заключена в следующем. Если левая граница запроса нечетна (то есть если `l&1`), то `l` -- правый сын своего родителя. Это значит, что интервал включает `l`, но не включает его родителя. Тогда добавим `t[l]` в ответ и сдвинем границу вбок и вверх (`l = (l + 1) / 2`). Если `l` четно, что это левый сын и интервал включает в себя его родителя (пока конечно правая граница не мешает), так что можно просто перейти к предку (`l = l / 2`). Аналогичные рассуждения можно провести для правой границы. Останавливается алгоритм при совпадении левой и правой границ.

Никакой рекурсии. Не нужно вычисять середину интервала. Просто проход по всем затрагиваемым вершинам и ничего лишнего.

### Массив любой длины

К этому моменту были обсуждены массивы размера степени 2, так что ДО содержало все вершины. Следующий факт может вас шокировать, так что подготовьтесь.

> *Приведенный код работает для любой длины.*

Обхяснение этого факта сложнее, чем раньше, так что сначала поймем преимущества этого подхода.

1. ДО использует ровно ~2n~ памяти, а не ~4n~, как предлагают некоторые реализации (привет, е-маккс!).

2. Элементы массива хранятся сплошным массивом с индекса ~n~.

3. Все операции очень эффективны и легко пишкуся.

Следующую часть можно пропустить и просто протестировать код, проверив корректность. Но для тех, кому все-таки нужно объяснение, рассмотрим пример ~n = 13~.

![](img/segtree_ranges_2.png)

Теперь это не одно двоичное дерево, а лес из полных двоичных деревьев: корень 2 высота 4, корень 7 высота 2, корень 13 высота 1. Вершины, отмеченные черточками на картинке вообще никогда не учавствуют в запросах, так что там может быть что угодно. Хоть листья и находятся на разной высоте, это исправимо: режем дерево перед 13-й вершиной и приставляем правую часть слева. I believe the resulting structure can be shown to be isomorphic to a part of larger perfect binary tree with respect to operations we perform, and this is why we get correct results.

Формального доказательства не будет, просто покажем на примере. Рассмотрим интервал `[0; 7)`. Изначально `l = 13, r = 20`, `l&1 => add t[13]` и границы смещаются на `l = 7, r = 10`. Снова `l&1 => add t[7]`, границы смещаются на `l = 4, r = 5`, вершины на одной высоте. Теперь `r&1 => add t[4 = --r]`, границы переходят на `l = r = 2`, алгоритм заканчивается.

### Изменение на отрезке, значение в точке

Некоторым приходят в голову очень сложные идеи, если поменять запросы местами, к примеру

1. Добавить значение ко всем элементам на отрезке

2. Найти значение определенного элемента

Но все, что нужно сделать, это поменять `modify` и `query`:

```cpp
void modify(int l, int r, int value) {
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) t[l++] += value;
    if (r&1) t[--r] += value;
  }
}

int query(int p) {
  int res = 0;
  for (p += n; p > 0; p >>= 1) res += t[p];
  return res;
}
```

Идея этого кода в том, что теперь мы храним изменения между соседними элементами, а не сам массив, поэтому значение элемента это префсумма.

Если надо просмотреть весь массив, то надо пропушить все изменения в листья. Такой код позволит получить все элементы за $\O(n)$, а не $\O(n\log n)$ так же, как и использование `build` вместо `n` запросов обновления.

```cpp
void push() {
  for (int i = 1; i < n; ++i) {
    t[i<<1] += t[i];
    t[i<<1|1] += t[i];
    t[i] = 0;
  }
}
```

Однако стоит признать, что подобный код работает, если порядок изменений отдельного элемента не влияет на конечный результат. К примеру, присваивание этому условию не удовлетворяет. Подробнее этот случай будет рассмотрен в разделе "Отложенные операции".

### Некоммутативные комбинаторы

Был рассмотрен очень простой комбинатор -- сложение. Он является коммутативным, то есть обладает переместительным свойством: ~a + b = b + a~. То же самое применимо к умножению, $\gcd$, $\min$, $\max$, так что можно просто заменить все вхождения `+` на любую из этих функций и все будет работать. Самое главное, не забыть сменить нейтральный элемент.

Но в реальном мире существуют задачи с неассоциативными комбинаторами, как к примеру [380C Серёжа и скобочки](https://codeforces.com/contest/380/problem/C). К счастью, данная реализация легко поддерживает такое изменение. Определим структуру `S` и функцию-комбинатор `S combine(S, S)` для нее. В `build` просто заменяем `+` а эту функцию. В `modify` требуется соблюдать правильный порядок детей, зная, что у левого сына четный индекс. В ответе на запрос левая граница идет слева направо, а правая --- справа налево, и в коде выглядеть это будет так:

```cpp
void modify(int p, const S& value) {
  for (t[p += n] = value; p >>= 1; ) t[p] = combine(t[p<<1], t[p<<1|1]);
}

S query(int l, int r) {
  S resl, resr;
  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
    if (l&1) resl = combine(resl, t[l++]);
    if (r&1) resr = combine(t[--r], resr);
  }
  return combine(resl, resr);
}
```

## Отложенные операции

Отложенные операции позволяют отвечать на запросы на отрезках и делать изменения ан отрезках. Для начала, введем немного переменных:

```cpp
int h = sizeof(int) * 8 - __builtin_clz(n);  // h = log2(n)
int d[N]; 
```

`h` --- высота дерева, то есть наибольший единичный бит в `n`. `d[i]` это список отложенных операций, которые необходимо протолкнуть в детей вершины `i` при надобности (из примеров станет понятнее). Размер массива только `N`, поскольку у листьев нет детей. Итого потребление памяти составляет ~3n~.


