# Хэширование в нестроковых задачах

> Первое правило хешей -- никогда не используй хеши. (c) レッドねこ

Хэш — это какая-то функция, сопоставляющая объектам какого-то множества числовые значения из ограниченного промежутка.

Введение в хеши можно прочитать [тут](hash.html).

## Хеширование множеств

**Задача.** Хотим научиться сравнивать множества чисел/строк на равенство с точностью до перестановки. Например, 

```
      {1,2,3} == {2,1,3}
{"lal","abc"} == {"abc","lal"}
        {4,5} != {5,6}
{"lal","abc"} != {"abc","all"}
```

При этом мы знаем, что количество различных значений, которые могут принимать ключи (объекты, которые лежат в множествах) невелико.

**Решение.** Сопоставим каждому ключу различные случайные числа (будем называть их хешом ключа) от ~0~ до некоторого ~M~ (в целом, можно и по модулю `LLONG_MAX`), а хешом множества будет считать сумму хешей всех входящих в него ключей. Тогда, очевидно, хеши равных (с точностью до перестановки) множеств будут одинаковые из-за коммутативности сложения, а вероятность коллизий при таком подходе в условиях олимпиад можно считать пренебрежимо малой.

## Хеширование матриц

**Задача.** Вам дана матрица $M_{i, j}$ размера $H \times W$, состоящая из чисел, и $Q$ запросов вида ''равны ли подматрицы $M_{x_1 \leq i \leq x_2, y_1 \leq j \leq y_2}$ и $M_{x_3 \leq i \leq x_4, y_3 \leq j \leq y_4}$.

### Решение за $\O(\text{число строк в запросе})$

Давайте посмотрим на матрицу как на набор строк. Тогда сравнивать подматрицы это то же самое, что сравнивать несколько раз подстроки на равенство, а это мы уже умеем делать хешами.

### Решение за $\O(1)$

Давайте обобщим идею полиномиального хеширования строк на матрицы. Для этого нам понадобится два разных $p ~- p_h$ и $p_v$.

Положим теперь 

```latex
h\Big(M_{x_1 \leq i \leq x_2, y_1 \leq j \leq y_2}\Big) = \Big[\sum_{x_1 \leq i \leq x_2, y_1 \leq j \leq y_2} M_{i, j} \times p_h^{i} \times p_v^{j}\Big] \times \underbrace{ p_h^{x_1} \times p_v^{y_1}}_{\substack{\text{поправка, учитывающая сдвиг от (0, 0)} \\ \text{ниже мы поймём, зачем она нужна}}}.
```

#### Предподсчёт за $\O(n^2)$

Предподсчитаем хеши для всех ''угловых'' подматриц (обобщение понятия префикс строки).
Сперва заметим, что для всех угловых подматриц, которые содержат только первую строку, определение хеша совпадает с определением полиномиального хеша для строки, а значит такие хеши мы умеем предподсчитать за линию. Аналогично с угловыми подматрицами, которые содержат только первый столбец.

Теперь заметим, что для всех остальных подматриц $h(x, y) = h(x-1, y) + h(x, y-1) - h(x-1, y-1) + M_{x, y}p_h^x p_v^y$. Значит, для всех $H \times W$ угловых подматриц мы умеем считать хеш за $\underbrace{\O(H) + \O(W)}_{\text{хеши первой строки и столбца}} + (H-1) \times (W-1) \times \O(1) = \O(H \times W)$.

#### Проверка на равенство за $\O(1)$

Заметим, что $h(x_1, y_1, x_2, y_2) = h(x_2, y_2) - h(x_1 - 1, y_2) - h(x_2, y_1 - 1) + h(x_1 - 1, y_1 - 1)$. Однако, это стало возможно только благодаря той добавке, которую мы добавили в определение хеша подматрицы, поэтому теперь, чтобы сравнить две подматрицы, надо хеш той из них, у которой $x$-координата левого верхнего угла меньше, домножить на $p_h^{|x-x'|}$, а хеш той, у которой $y$-координата левого верхнего угла меньше, домножить на  $p_v^{|y-y'|}$ (заметьте, что это может быть одна и та же матрица). Теперь, если получившиеся хеши равны, то мы можем с большой долей уверенности говорить, что исходные матрицы тоже были равны.

## Хеширование корневых деревьев

**Задача.** Хотим научиться сравнивать корневые деревья на изоморфизм (равенство с точностью до перенумерования вершин + корень одного дерева обязательно переходит в корень другого дерева).

### Хеш вершины

Заметим, что поскольку мы не можем аппелировать к номерам вершин, единственная информация, которую мы можем оперировать $~-$ это структура нашего дерева.

Положим тогда хешем вершины без детей какую-нибудь константу (например, 179), а для вершины с детьми положим в качестве хеша некоторую функцию от отсортированного (поскольку мы не знаем истинного порядка, в котором дети должны идти, нужно привести их к одинаковому виду) списка хешей детей. Хешом корневого дерева будем считать хеш корня.

По построению, у изоморфных корневых деревьев хеши совпадают (доказательство индукцией по числу уровней в дереве автор оставляет читателю в качестве упражнения).

**Полиномиальный хеш не подходит.** Рассмотрим 2 дерева: $T_1 = \{ (1 2), (1 3), (1 4) \}$ и $T_2 = \{ (1 2), (1 3), (3 4), (3 5) \}$. Если мы посчитаем для них в качестве функции от детей взять полиномиальный хеш, то получим: $h(T_1) = 179 + 179p + 179p^2 = 179 + p(179 + 179p) = h(T_2)$

В качестве хорошей хеш-функции подойдёт, например

$$ h(v) = 42 + \sum_{u \in sorted\_by\_hash(child(v))} log(h(u)) $$

Для этой хешфункции может показаться, что можно не сортировать хеши детей, однако это не так, потому что при вычислении чисел с плавающей точкой у нас возникает погрешность, и чтобы это результат суммирования был одинаковый для изоморфных деревьев, суммировать детей надо тоже в одинаковом порядке.

Пример более complicated хеш-функции:
$$ h(v) = \big[\sum_{u \in sorted\_by\_hash(child(v))} h(u)^2 + h(u) p^i + 42 \big] \mod 2^{64} $$

Всё что нам нужно делать на каждом уровне $~-$ это сортировка вершин по размеру хеша и суммирование, так что итоговая сложность: $\O(|V| log(|V|))$

## Хеш-таблицы

todo
