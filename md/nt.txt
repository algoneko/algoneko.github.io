# Теория чисел

> Не можешь понять материал -- объясни его другим

## Простые числа

**Простое число** — это натуральное число, которое имеет ровно 2 различных натуральных делителя, единицу и само себя. Единица не является простым числом.

**Составное число** — это любое натуральное число, не являющееся простым. Некоторые не относят единицу к составным числам.

Примеры простых чисел: ~2~, ~3~, ~5~, ~179~, ~10^9+7~, ~10^9+9~, ~2286661337~, ~119*2^23+1=998244353~.

Примеры составных чисел: ~4~, ~15~, ~230~, ~10^9~, ~2^32~.

Вообще, про простые числа известно много свойств, но почти все из них очень трудно доказать. Вот некоторые из них:

* Простых чисел, меньших $N$, примерно $\frac{N}{\ln N}$.
* N-ое простое число равно примерно $N\ln N$.
* Простые числа распределены более-менее равномерно. Например, если вам нужно найти какое-то простое число в промежутке, то можно их просто перебрать и проверить — через несколько сотен какое-нибудь найдется.
* Для любого $N \ge 2$ на интервале $(N, 2N)$ всегда найдется простое число [(Постулат Бертрана)](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D1%83%D0%BB%D0%B0%D1%82_%D0%91%D0%B5%D1%80%D1%82%D1%80%D0%B0%D0%BD%D0%B0)
* Впрочем, существуют сколь угодно длинные отрезки, на которых простых чисел нет. Самый простой способ такой построить - это начать с $N! + 2$.
* Есть алгоритмы, проверяющие число на простоту намного быстрее, чем за корень.
* [Максимальное число делителей](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D0%B5%D0%B9) равно примерно $O(\sqrt[3]{n})$. Это не математический результат, а чисто эмпирический — не пишите его в асимптотиках.
    * Максимальное число делителей у числа на отрезке $[1, 10^5]$ — 128
    * Максимальное число делителей у числа на отрекзке $[1, 10^9]$ — 1344
    * Максимальное число делителей у числа на отрезке $[1, 10^{18}]$ — 103680
* Наука [умеет](pollard.html) факторизовать числа за $\O(\sqrt[4]{n})$, но об этом как-нибудь в другой раз.
* Любое число больше трёх можно представить в виде суммы двух простых [(гипотеза Гольдбаха)](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%B1%D0%B0%D1%85%D0%B0), но это не доказано.

## Проверка числа на простоту

$N$ - число, для которого мы определяем, простое ли оно.

### Проверка на простоту за $\O(N)$

Линейная проверка очень простая - надо просто перебрать все числа от $2$ до $N - 1$ и проверить, что $N$ не делится ни на одно из них. Отдельно обрабатывается случай для $N = 1$.

```cpp
bool isPrime(int n) {
    if (n < 2)
        return false;
    for (int i = 2; i < n; ++i) {
        if (n % i == 0) {
            return false;
    return true;
}
```

### Ускорение до $\O(\sqrt{N})$

**Утверждение.** Пусть $N = a \times b$, причем $a \leq b$. Тогда $a \leq \sqrt N \leq b$.

**Доказательство.** Если $a \leq b < \sqrt{N}$, то $ab \leq b^2 < N$, но $ab = N$. А если $\sqrt{N} < a \leq b$, то $N < a^2 \leq ab$, но $ab = N$.

Иными словами, если число $N$ равно произведению двух других, то одно из них не больше корня из $N$, а другое не меньше корня из $N$.

Из этого следует, что если число $N$ не делится ни на одно из чисел $2, 3, 4, \ldots, \bigl\lfloor\sqrt{N}\bigr\rfloor$, то оно не делится и ни на одно из чисел $\bigl\lceil\sqrt{N}\bigr\rceil + 1,  \ldots, N-2, N-1$, так как если есть делитель больше корня (не равный $N$), то есть делитель и меньше корня (не равный $1$). Поэтому в цикле <tt>for</tt> достаточно проверять числа не до $N$, а до корня.

```cpp
bool isPrime(int n) {
    if (n < 2)
        return false;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0)
            return false;
    return true;
}
```

## Разложение на множители

Любое натуральное число можно разложить на произведение простых (об этом говорит [основная теорма арифметики](https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B8)), и с такой записью очень легко работать при решении задач.

**Факторизация** -- разложение на простые множители.

**Примеры:**
$$11 = 11 = 11^1$$
$$100 = 2 \times 2 \times 5 \times 5 = 2^2 \times 5^2$$
$$126 = 2 \times 3 \times 3 \times 7 = 2^1 \times 3^2 \times 7^1$$

Рассмотрим такую задачу: Нужно разбить $N$ людей на группы равного размера. Нам интересно, какие размеры это могут быть и сколькими способами это можно сделать.

**Решение:** По сути нас просят найти число различных делителей $N$. Нужно посмотреть на разложение числа $N$ на простые множители, в общем виде оно выглядит так:

$$N= p_1^{a_1} \times p_2^{a_2} \times \ldots \times p_k^{a_k}$$

Теперь подумаем над этим выражением с точки зрения комбинаторики. Чтобы «сгенерировать» какой-нибудь делитель, нужно подставить в степень $i$-го простого число от 0 до $a_i$ (то есть $a_i+1$ различное значение), и так для каждого. То есть делитель $N$ выглядит ровно так:
$$M= p_1^{b_1} \times p_2^{b_2} \times \ldots \times p_k^{b_k}, \ \ 0 \leq b_i \leq a_i$$ю

Значит, ответом будет произведение $(a_1+1) \times (a_2+1) \times \ldots \times (a_k + 1)$.

Применяя алгоритм проверки числа на простоту, мы умеем легко находить __минимальный простой делитель числа N__. Ясно, что как только мы нашли простой делитель числа $N$, мы можем число $N$ на него поделить и продолжить искать новый минимальный простой делитель.

Будем перебирать простой делитель от $2$ до корня из $N$ (как и раньше), но в случае, если $N$ делится на этот делитель, будем просто на него делить. Причем, возможно, нам понадобится делить несколько раз ($N$ может делиться на большую степень этого простого делителя). Так мы будем набирать простые делители и остановимся в тот момент, когда $N$ стало либо $1$, либо простым (и мы остановились, так как дошли до корня из него). Во втором случае надо еще само $N$ добавить в ответ.

```cpp
vector<int> factorize(int N) {
    vector<int> result;
    for (int i = 2; i * i <= N; ++i) {
        while (N % i == 0) {
            result.push_back(i);
            N /= i;
        }
    }
    if (N != 1)
        result.push_back(N);
    return result;
}
```

Заметим, что итераций цикла `for` будет не более $\bigl\lceil\sqrt{N}\bigr\rceil$, то есть $\O\left(\sqrt{N}\right)$. При делении на какое-то простое число $N$ уменьшается хотя бы в два раза, поэтому суммарное число итераций цикла `while` не превосходит $\log N$. Значит, весь алгоритм работает за $\O\left(\log N + \sqrt{N}\right) = \O\left(\sqrt{N}\right)$.

## Модульная арифметика

Говоря о теории чисел, мы будем работать с __остатками__.

**Остаток от деления $a$ на $b$** — это такое число ~0 le c<b~, что ~a=bq+c~ для некоторого целого ~q~.

Выражение $a \equiv b \pmod m$ означает, что остатки от деления $a$ на $m$ и $b$ на $m$ равны. Это выражение читается как «$a$ сравнимо $b$ по модулю $m$». 

Еще это можно опрделить так: $a$ сравнимо c $b$ по модулю $m$, если $(a - b)$ делится на $m$. 

Все целые числа можно разделить на <em>классы эквивалентности</em> — два числа лежат в одном классе, если они сравнимы по модулю $m$. Говорят, что мы работаем в «кольце остатков по модулю $m$», и в нем ровно $m$ элементов: $0, 1, 2, \cdots, m-1$.

Сложение, вычитение и умножение по модулю определяются довольно интуитивно — нужно выполнить соответствующую операцию и взять остаток от деления.

**Некоторые свойства:**

* $a \equiv b$, $c \equiv d \Rightarrow a \pm c \equiv b \pm d \mod m$
* $a \equiv b$, $c \equiv d \Rightarrow ac \equiv bd \mod m$
* $a\equiv b \mod m \Rightarrow a^n \equiv b^n \mod m$

### Деление по модулю

Поделить одно число $a$ на другое число $b$ в кольце вычетов по модулю $m$ — значит найти такое число $c$, что $cb \equiv a \mod m$. Эта задача уже сложнее, чем сложение и умножение по модулю. Она сводится у нахождению так называемого __обратного по модулю__ к числу $b$. 

Обратным к числу $a$ по модулю $m$ называют такое число $a^{-1}$, что $a\cdot a^{-1} \equiv 1 \mod m$.

В том случае, если модуль простой (является простым числом), найти обратный всегда можно, только если исходное число не делится на модуль $m$. Если же модуль — составное число, то обратный элемент к $a$ существует только тогда, когда $(a, m) = 1$, то есть когда $a$ и $m$ взаимнопросты.

**Утверждение.** Обратный элемент существует только для чисел, взаимно простых с модулем.

**Доказательство.** Сначала покажем, что для взаимно простого с $m$ числа обратный всегда найдется. Так как мы работаем только с остатками по модулю $m$, то будем считать одним и тем же объектом число и его остаток.

Рассмотрим числа $0\cdot a, 1\cdot a, ... , (m-1)\cdot a$. Поймем, что это __различные__ остатки по модулю $m$. Допустим, есть два одинаковых и это $xa$ и $ya$. Тогда $a(x - y) \equiv 0 \mod m$. Но так как $(a, m) = 1$, то $x - y \equiv 0 \mod m$. Но оба числа $x, y$ лежат на отрезке $[0, m-1]$. Так как их разность сравнима с нулем, то они могут быть только одинаковыми числами, иначе их разность будет находиться в отрезке $[1, m-1]$. Значит, все остатки различны. Так как их $m-1$ штука, то обязательно встретится остаток $1$. То есть найдется $ka \equiv 1 \mod m$ — обратный по модулю $m$ к числу $a$.

Теперь покажем, что для чисел, не взаимно простых с $m$, обратного не существует. Пусть $(a, m) = b > 1$. Тогда если есть обратный, то $aa^{-1} \equiv 1 \mod m$. 

$a = bt, \ m = bp$

$bta^{-1}-1=bp \Rightarrow b\left(ta^{-1} - p\right) = 1 \Rightarrow b \mid 1$ — противоречие.

Значит, обратный элемент существует для тех и только тех элементов, которые взаимно просты с модулем $m$.


Если мы нашли обратное к $b$ число, то $ab^{-1} \equiv bcb^{-1} \equiv c \mod m$. То есть умножив $a$ на обратное к $b$ число, мы выполнили деление и нашли искомое $c$.

О том, как искать обратный по модулю читайте в [отдельной статье](reciprocal.html).

```cpp
const int mod = 1e9 + 7; // Поменяйте на тот, который в вашей задаче

template<typename T>
T add(T x) {
    return x;
}

template<typename T, typename... Ts>
T add(T x, Ts... y) {
    T res = x + add(y...);
    if (res >= mod)
        res -= mod;
    return res;
}
// Конструкция выше позволяет писать add(x, y, z, t, ...) с любым количеством аргументов 

template<typename T, typename... Ts>
T sub(T x, Ts... y) {
    return add(x, mod - add(y...));
}

// udd это add, записывающий результат сложения в первый аргумент. 
// Старое значение первого аргумента в сумме участвует
template<typename T, typename... Ts>
void udd(T &x, Ts... y) {
    x = add(x, y...);
}


template<typename T>
T mul(T x) {
    return x;
}

template<typename T, typename... Ts>
T mul(T x, Ts... y) {
    return (x * 1ll * mul(y...)) % mod;
}

template<typename T, typename... Ts>
void uul(T &x, Ts... y) {
    x = mul(x, y...);
}

int bin(int a, ll deg) {
    int r = 1;
    while (deg) {
        if (deg & 1)
            uul(r, a);
        deg >>= 1;
        uul(a, a);
    }
    return r;
}

// обратный по __простому__ модулю
int inv(int x) {
    assert(x);
    return bin(x, mod - 2);
}
```

## Бинарное возведение в степень

Заметим, что возвести число $a$ в степень $p$ можно быстрее, чем за $p - 1$ умножение. Мы будем пользоваться следующим соображением:

Если $p = 2q$, то $a^p = a^{2q} = \left(a^q\right)^2$. Значит, нам достаточно посчитать $a^q$, чтобы посчитать $a^p$. Если $p = 2q + 1$, то просто посчитаем $a^{2q}$ и умножим на $a$.

Сразу напрашивается рекурсивная реализация этого алгоритма:

```cpp
int binPow(int a, int p) {
    if (p == 0)
        return 1;  // Случай `a = 0` не очень корректен
    int aq = binPow(a, p / 2);
    aq *= aq;
    if (p % 2 == 1)
        aq *= p;
    return aq;
}
```

Эта реализация - рекурсивная, что работает долго. Поэтому стоит использовать **нерекурисвную**.

Опять рассмотрим двоичное представление числа $p$. Заведем текущую степень числа $a$ - $a^t$. При проходе от младших разрядов к старшим будем возводить текущую степень в квадрат, то есть $t$ увеличивается на каждом шаге в два раза. Если бит в текущем разряде выставлен бит, то умножим набираемый ответ на текущую степень.

```cpp
int fastBinPow(int a, int p) {
    int cur = a;
    int ans = 1;
    while (p > 0) {
        if (p & 1)
            ans *= cur;
        p /= 2;
        cur *= cur;
    }
    return ans;
}
```

В каждом из двух случаев делалось столько итераций цикла или вызовов, сколько в числе бит, то есть все работает за $\O(\log n)$ при условии, что умножение работает за $\O(1)$.
