# BFS и кратчайшие пути в графе

TODO переписать описание по-нормальному.

## BFS

BFS (англ. breadth-first search, поиск в ширину) -- один из алгоритмов обхода графа. Асимптотика $\O(n + m)$. Алгоритм работает следующим образом.

1. Создадим массив `dist` расстояний. Изначально `dist[s] = 0` (поскольку расстояний от вершины до самой себя равно 0) и `dist[v] = INF` для `v != s`.

2. Создадим очередь `q`. Изначально в `q` добавим вершину `s`.

3. Пока очередь `q` непуста, делаем следующее:

    - Извлекаем вершину `v` из очереди.

    - Рассматриваем все рёбра `(v, u) in E`. Для каждого такого ребра пытаемся сделать релаксацию: если `dist[v] + 1 < dist[u]`, то мы делаем присвоение `dist[u] = dist[v] + 1` и добавляем вершину `u` в очередь.

Можно представить, что мы поджигаем вершину ~s~. Каждый шаг алгоритма — это распространение огня на соседние вершины. Понятно, что огонь доберётся до вершины по кратчайшему пути.

Заметьте, что этот алгоритм очень похож на [DFS](dfs.html) — достаточно заменить очередь на стек и поиск в ширину станет поиском в глубину. Действительно, оба алгоритма при обработке вершины просто записывают всех непосещенных соседей, в которые из неё есть ребро, в структуру данных, и после этого выбирает следующую вершину для обработки в структуре данных. В DFS это стек (благодаря рекурсии), поэтому мы сначала записываем соседа, идем в обрабатываем его полностью, а потом начинаем обрабатывать следующего соседа. В BFS это очередь, поэтому мы кидаем сразу всех соседей, а потом начинаем обрабатывать вообще другую вершину - ту непосещенную, которую мы положили в очередь раньше всего.

Оба алгоритма позволяют обойти граф целиком - посетить каждую вершину ровно один раз. Поэтому они оба подходят для таких задач как:
- поиск компонент связности
- проверка графа на двудольность
- построение остова

### Код

```cpp
vector<int> bfs(int s) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n, если v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    queue<int> q;
    q.push(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : adj[v]) {
            if (dist[u] > dist[v] + 1) {
                dist[u] = dist[v] + 1;
                q.push(u);
            }
        }
    }

    return dist;
}
```

## 0-1 BFS

Задача: вам дан взвешенный граф ~G~, веса рёбер которого принимают значения 0 (0-рёбра) и 1 (1-рёбра) и выделена вершина ~v~ в нём. Вас просят найти в этом графе кратчайшие расстояния от ~v~ до всех остальных вершин.

Идея: если от вершины ~v_1~ до вершины ~v_2~ можно дойти по пути, состоящему из рёбер веса 0, то кратчайшие расстояния до этих вершин совпадают.

Заметим тогда, что если в нашем графе оставить только 0-рёбра, то он распадётся на компоненты связности (возможно, некоторые будут иметь размер 1), в каждой из которых ответ одинаковый. Если теперь вернуть 1-рёбра, и сказать, что эти рёбра соединяют не вершины, а компоненты связности, то мы сведём задачу к обычному BFS-у.

А чтобы решить исходную задачу, надо при посещении первой вершины из компоненты обойти всю компоненту, проставив во всех вершинах такой же ответ, как и у первой вершины. Как же можно обойти всю компоненту? Запустить BFS на 0-рёбрах!

А теперь заметим, что на самом деле нам не нужно запускать BFS внутри BFS, достаточно при посещении вершины добавлять всех её непосещённых соседей по 0-рёбрам в голову очереди, чтобы обработать их раньше, чем следующие в очереди.

А какая структура данных позволяет нам добавлять вершины не только в хвост, но и в голову? Это же дэк!

### Код

```cpp
vector<int> zero_one_bfs(int start_vertex) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n <=> v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    deque<int> pending;
    pending.push_back(s);

    while (!pending.empty()) {
        int v = pending.front();
        pending.pop_front();
        for (auto&& [to, w] /* конец ребра и его вес */ : adj[v]) {
            if (dist[to] > dist[v] + w) {
                dist[to] = dist[v] + w;
                if (w == 0) {
                    pending.push_front(to);
                } else {
                    pending.push_back(to);
                }
            }
        }
    }

    return dist;
}
```

## 1-k BFS

Задача: вам дан взвешенный граф ~G~, веса рёбер которого принимают значения от ~1~ до ~k~ и выделена вершина ~s~ в нём. Вас просят найти в этом графе кратчайшие расстояния от ~s~ до всех остальных вершин.

Поскольку в графе нет рёбер отрицательного веса, то максимальное кратчайшее расстояние в нём равно ~(|V|−1)k~.

Давайте для каждого расстояния ~d~ заведём ~atdist[d]~ -- очередь вершин, которые находятся на таком расстоянии от ~s~ плюс, возможно, некоторые вершины, до которых существует путь длины ~d~ от ~s~, но для которых существует более короткий путь. Получится ~(|V|−1)k~ списков.

Как посчитать эти списки?

База) ~atdist[0] = s~

Шаг) Если вершина ~v~ лежит в списке ~atdist[d]~, то любой из её ранее непосещённых соседей, достижимых по ребру веса ~w~ лежит в списке с номером не более ~atdist[d+w]~. Давайте тогда её добавим в этот список. Однако, надо помнить, что на самом деле кратчайшее расстояние до неё может быть и меньше, чем ~d+w~.

Если для всех вершин до уровня ~d~ расстояния посчитаны корректно, то на уровне ~d+1~ сейчас находятся те вершины, до которых расстояние равно ~d+1~ плюс, возможно, дубликаты вершин, до которых мы в какой-то момент нашли путь длины ~d+1~, а затем нашли более короткий (разумеется, более длинные пути мы не будем рассматривать). Доказательство по индукции.

Заметим, что на самом деле мы можем обойтись ~k+1~ списками, поскольку обрабатывая рёбра, мы никогда не уходим вперёд на более, чем ~k~ очередей, а старые очереди мы тем более не используем. Поэтому вместо добавления в ~atdist[d+w]~ мы будем добавлять в `atdist[(d + w) % atdist.size()]`.

Сложность алгоритма $\O(k|V|+|E|)$, поскольку каждую вершину мы можем прорелаксировать (найти более оптимальный ответ) и добавить в другую очередь не более ~k~ раз, а просматривать рёбра, исходящие из вершины мы будем только когда обнаружим эту вершину в самый первый раз.

## Кратчайшите пути

Рассмотрим **взвешенный граф**, то есть у всех его ребер есть вес - некоторое число. Можно представить, что это цена, за которую мы можем по нему проехать.

Как его хранить? Давайте просто в списке смежности вместо номеров вершин соседа хранить пару (номер соседа, вес ребра до него).

Давайте решать задачу посика кратчайшего пути в графе - мы хотим за наименьшую стоимость проехать из вершины $A$ в $B$.

Обычно будем считать, что в графе нет циклов отрицательного веса - иначе кратчайшее расстояниие может быть равно минус бесконечности.

Для данной задачи есть несколько алгоритмов решения.

## Алгоритм Флойда

Мы с вами уже знаем динамическое программирование, давайте рассмотри следующую динамику:

$d_{i j}^k$ - это длина кратчайшего пути от вершины $i$ до $j$, используя как промежуточные только вершины из первых $k$ = $d_{i j}^k$ (напоминает рюкзак).

База динамики ($k = 0$) определяется только путями из одного ребра. Если есть ребро из $i$ в $j$ стоимостью $c$, то $d_{i j}^{0}$ = $c$. Если таких ребер несколько, то, конечно, надо взять минимум.

 Если мы хотим посчитать $d_{i j}^{k}$, то у нас есть два варианта
 
 1) Не брать на пути нигде $k$-ую вершину, тогда $d_{i j}^{k}$ = $d_{i j}^{k - 1}$
 
 2) Взять где-нибудь в пути k-ую вершину, тогда путь разбивается на две части - от $i$ до $k$ и от $k$ до $j$, раз итоговый путь кратчайший, то и и эти два пути должны быть кратчайшми, а значит формула $d_{i j}^{k}$ = $d_{i k}^{k - 1}$ + $d_{k j}^{k - 1}$
 
 В результате ответ - $d_{A B}^{n}$,
 
 Можете подумать, как по такой динамике восстановить сам путь.
 
 Также заметим, что вместо трехмерной динамики в этом алгоритме можно использовать двухмерную, храня в $dp_{ij}$ последнее известное значение из $dp_{ij}^0$, $dp_{ij}^1$ $dp_{ij}^2$, $\ldots$, $dp_{ij}^n$.


```cpp
for(int k = 0; k < n; k++){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
        }
    }
}
```

### Теоретическое задание

Подумайте, как находить циклы отрицательного веса с помощью Флойда.

Плюсы алгоритма в том, что он находит расстояние сразу от всех вершин графа до остальных, а минус - алгоритм работает за $\O(N^3)$;

## Алгоритм Дейкстры

Для этого алгоритма придется рассматривать только графы без отрицательных рёбер.

Алгоритм Дейкстры решает немного другую задачу: он находит расстояние от **одной** вершины $A$ до **каждой** вершины. Давайте для каждой вершины хранить расстояние до нее из вершины $A$ в массиве $d$. Например:
* $d[A] = 0$
* $d[x] = \infty$, если x не достижима из A

Назовем **релаксацией** обновление ответа для вершины $b$ через ребро $(a, b, c)$ таким способом: $d[b] = \min(d[b], d[a] + c)$.

* При таком действии ответ не может стать лучше, чем кратчайшее расстояние до $b$, так как мы просто пользуемся путем для вершины $a$ и продлеваем его в $b$.
* Если мы прорелаксировали все ребра в кратчайшем пути в правильном порядке до вершины $b$, то мы получим кратчайший путь до $b$.

Теперь давайте каждый раз доставать вершину, для которой расстояние от А сейчас минимально, и мы еще ее не смотрели и затем обновлять всех ее соседей. Допустим вершина с минимальным расстоянием - x, тогда надо прорелаксировать все ребра из нее.  

Давайте докажем корректность алгоритма по индукции:

База) Первой вершиной мы всегда рассмотрим $A$, но для нее верно, что расстояние от $А$ до $А$ = 0;

Шаг) Мы достали вершину $i$, нам известно, что для всех ее предков ответ - корректен, но тогда, допустим, что для $i$-ой вершины мы нашли ответ больший, чем надо, тогда это значит, что мы должны прийти из еще не рассмотренной вершины, но так как ребер отрицательного веса в графе нет, то такое невозможно $\Rightarrow$ мы доказали

https://visualgo.net/en/sssp?slide=1

Есть две возможные реализации алгоритма

1) реализация помощью нахождения минимального расстояния внутри массива за линию. Так как мы для каждого шага находим минимальную вершину, то мы сделаем не более $N$ шагов, но при этом на каждом шаге мы находим минимум за линию, то есть алгоритм работает за $\O(N^2)$.


```cpp
for (int i = 0; i < n; ++i){
    int uk = -1;
    for (int j = 0; j < n; j++){
        if ((mark[j] == 0) && ((uk == -1) || (d[j] < d[uk]))){
                uk = j;
        }
    }
    for (int j = 0; j < n; j++){
        if ((j != uk) && (g[uk][j] != -1)) d[j] = min(d[j], g[uk][j] + d[uk]);
    }
    mark[uk] = 1;
}
```

2) Реализация за $\O(MlognN + NlogN)$ с помощью нахождения минимального расстояния внутри кучи/сета за логарифм. Так как для каждой вершины мы сделаем не более одного извлекания из структуры + каждое ребро мы используем максимум два раза. Для этого давайте в выбранной структуре хранить пару (расстояние, вершина); Первый код реализован с set, второй с кучей. Так как в куче нет компаратора на возрастание, то надо либо сделать свой, либо домножить расстояние на -1;


```cpp
while (used.size()) {
    int v = (*(used.begin())).second;
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v][i].first, c = g[v][i].second;
        if (dist[v] + c < dist[to]) {
            used.erase({dist[to], to});
            dist[to] = dist[v] + to;
            used.insert({dist[to], to});
        }
    }
    used.erase({dist[v], v});
}
```


```cpp
while (!q.empty()) {
		int v = q.top().second;
		q.pop();
    for (int j = 0; j < g[v].size(); ++j) {
        int to = g[v][j].first, c = g[v][j].second;
        if (d[v] + c < d[to]) {
            d[to] = d[v] + c;
            q.push({-d[to], to});
        }
    }
}
```

### Из асимптотики понятно, что при большом количестве ребер первый алгоритм писать лучше, иначе второй.

### Теоретическое задание

Приведите примеры, когда каждый из алгоритмов работает лучше.

Недостаток алгоритма Дейкстры всего один - он не работает, если в графе есть ребра отрицательного веса.

## Форд-Беллман

Этот алгоритм решает ту же задачу, что и Дейкстра, но зато может работать с отрицательными ребрами!

Давайте заведем массив расстояний, как и в дейкстре, для стартовой вершины расстояние = 0. Алгоритм состоит в **релаксации каждого ребра в графе** $N-1$ раз.

Это работает потому, что в кратчайшем пути не больше, чем $N-1$ ребро, и если мы прорелаксируем их в таком порядке, этот путь найдется. После $N-1$ прохода по всем ребрам и их релаксации мы точно это сделаем и найдем кратчайший путь.

Также в этом случае удобнее хранить **список ребер** явно вместо списка смежности.




```cpp
int from[m], to[m], cost[m];
for (int i = 0; i < n - 1; ++i) {
		for (int j = 0; j < m; ++j) {
				d[to[j]] = min(d[to[j]], d[from[j]] + cost[j]);
    }
}
```

### Теоретическое задание

Подумайте, как найти цикл отрицательного веса с помощью этого алгоритма.

